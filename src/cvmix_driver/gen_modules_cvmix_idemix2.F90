!
!
!===============================================================================
! module interface to FESOM2.0 for the CVMIX IDEMIX2 extension for the calculation 
! of the internal wave energy and its dissipation in Turbulent Kinetic Energy
! vertical mixing scheme --> it is based one its pyOM2 implementation by Carsten Eden
!
! @see Olbers D., Eden C.:
!       A Global Model for the Diapycnal Diffusivity Induced Internal Gravity Waves.
!       J. Phys. Oceanogr., 43, 1759-1779. doi: 10.1175/JPO-D-12-0207.1, 2013.
! @see Eden C., Czeschel L., Olbers D.:
!       Towards Energetically Consistent Ocean Models. 
!       J. Phys. Oceanogr., 44, 3160-3184, doi: 10.1175/JPO-D-13-0260.1, 2014.
! written by Patrick Scholz, 10.05.2019
module g_cvmix_idemix2
    
    !___________________________________________________________________________
    ! module calls from cvmix library
    use cvmix_idemix2, only : cvmix_init_idemix2                    , &
                              cvmix_compute_groupvel_idemix2        , & 
                              cvmix_compute_interact_tscale_idemix2
                                             
    use cvmix_put_get, only : cvmix_put
    use cvmix_kinds_and_types 
    
    !___________________________________________________________________________
    ! module calls from FESOM
    use g_config , only: dt, flag_debug
    use o_param           
    use mod_mesh
    USE MOD_PARTIT
    USE MOD_PARSUP
    use o_arrays
    use g_comm_auto 
    use g_read_other_NetCDF
    use g_dist2coast, only: compute_dist2coast
    implicit none
    public
    
    !___________________________________________________________________________
    ! OCECTL/CVMIX_IDEMIX_PARAM namelist parameters
    ! time scale for vertical symmetrisation (sec)
    ! real(kind=WP) :: idemix_tau_v = 86400.0 ! old
    real(kind=WP) :: idemix2_tau_v = 172800.0  ! from Pollman et al. (2017), use 2days, 2*86400sec
    
    ! time scale for horizontal symmetrisation, only necessary for lateral diffusion (sec), 
    ! use 15days, 15*86400sec
    real(kind=WP) :: idemix2_tau_h = 1296000.0
    
    ! constant of order one derived from the shape of the spectrum in m space (dimensionless)
    real(kind=WP) :: idemix2_gamma = 1.570
    
    ! spectral bandwidth in modes (dimensionless), or mode number scale, it describes over 
    ! over how many equivalent modes the energy is spread
    ! real(kind=WP) :: idemix_jstar = 10.0 ! old 
    real(kind=WP) :: idemix2_jstar = 5.0    ! from Pollman et al. (2017)
    
    ! dissipation parameter (dimensionless)
    ! real(kind=WP) :: idemix_mu0   = 1.33333333 ! old 
    real(kind=WP) :: idemix2_mu0   = 0.33333333   ! from Pollman et al. (2017), use 2days

    ! enable M2 tidal component as significant source of internal wave energy in IDEMIX2, 
    ! lower frequency modes
    ! Frequency: Semi-diurnal (twice daily, ~12.42 hour period)
    ! Source   : Barotropic tidal flow over rough topography
    ! Energy   : Higher energy, lower frequency
    ! Impact   : Dominant in regions with strong tidal currents
    logical       :: idemix2_enable_M2    = .true.
    
    ! enable Near-Inertial Wave (NIW) component of the IDEMIX module. NIWs are generated by 
    ! wind stress and have frequencies close to the local inertial frequency.
    ! Frequency: Near the local inertial frequency (f, typically 1-4 cycles per day at mid-latitudes)
    ! Source   : Wind forcing, especially during storms
    ! Energy   : Lower energy, higher frequency than M2
    ! Impact   : Important in the upper ocean, especially after storms
    logical       :: idemix2_enable_niw   = .false.
    
    ! amount of surface for2cing that is used
    real(kind=WP) :: idemix2_fniw_usage   = 0.2
    
    ! use superbee-spectral advection scheme and Adams-Bashfort timestepping 
    logical       :: idemix2_enable_superbee_adv = .true.
    logical       :: idemix2_enable_AB_timestep  = .true.
    
    ! number of spectral bins used for the M2 tidal and near-inertial wave (niw) components
    ! e.g 50+2 in loop used as do fbin=2,51 ... 1 and 52 serve as spectral boudary condition
    ! The first and last bins are used for boundary conditions in the spectral space.
    ! They ensure smooth transitions and prevent numerical instabilities at the edges of the spectral domain.
    ! Numerical Stability: The advection scheme (e.g., Superbee) requires ghost cells or boundary values.
    ! Skipping the first and last bins avoids out-of-bounds errors when calculating gradients.
    integer       :: idemix2_nfbin=52
    
    ! enable idemix1 functionality of homogenous diffusion into all directions
    logical       :: idemix2_enable_hor_diffusion = .false.
    integer       :: idemix2_hor_diffusion_niter  = 5   ! from Pollman et al. (2017)
    
    ! filelocation for idemix2 M2 forcing (Summed anisotropic M2-tide generation modes 1-2 (W/m2))
    character(MAX_PATH):: idemix2_M2forc_file = './idemix2_IT_forc_M2modes1+2_aniso.nc'
    character(MAX_PATH):: idemix2_M2forc_vname= 'Flux_to2.nc'
    
    ! filelocation for idemix2 NIW forcing (near inertial waves)
    character(MAX_PATH):: idemix2_niwforc_file = './dummy.nc'
    character(MAX_PATH):: idemix2_niwforc_vname= 'dummy'
    
    ! filelocation for idemix2 bottom forcing
    character(MAX_PATH):: idemix2_botforc_file = './tidal_energy_gx1v6_20090205_rgrid.nc'
    character(MAX_PATH):: idemix2_botforc_vname= 'wave_dissipation'
    ! total global Energy input that should be conserved if 0.0 no conservation is applied
    real(kind=WP)      :: idemix2_botforc_Etot = 0.0_WP ! units W
    
    ! filelocation for idemix2 Root Mean Square Topographic Height forcing. Measures the roughness or 
    ! variability of seafloor topography. Units: Meters (m), Role: Represents the standard deviation 
    ! of seafloor height variations. Used to calculate energy transfer from tides/NIW to internal waves.
    character(MAX_PATH):: idemix2_hrmsforc_file = './idemix2_forcing_t-scattering_Goff2023_1deg.nc'
    character(MAX_PATH):: idemix2_hrmsforc_vname= 'HRMS'
    
    ! filelocation for idemix2 Characteristic horizontal length scale of topographic features.
    ! Units: Meters (m), Role: Represents the dominant wavelength of seafloor roughness. Used to 
    ! normalize the topographic forcing.
    character(MAX_PATH):: idemix2_hlamforc_file = './idemix2_forcing_t-scattering_1deg.nc'
    character(MAX_PATH):: idemix2_hlamforc_vname= 'LAMBDA_G10'
    
    ! define shelf is defined as distance from coast (default 300km)
    real(kind=WP)      :: idemix2_shelf_dist = 300.0e3 
    
    namelist /param_idemix2/ idemix2_tau_v, idemix2_tau_h, idemix2_gamma, idemix2_jstar, idemix2_mu0, &
                             idemix2_enable_M2, idemix2_enable_niw, idemix2_fniw_usage, &
                             idemix2_enable_superbee_adv, idemix2_enable_AB_timestep, idemix2_nfbin, &
                             idemix2_enable_hor_diffusion, idemix2_hor_diffusion_niter, &
                             idemix2_shelf_dist, &
                             idemix2_botforc_Etot, &
                             idemix2_M2forc_file  , idemix2_M2forc_vname  , &
                             idemix2_niwforc_file , idemix2_niwforc_vname , &
                             idemix2_botforc_file , idemix2_botforc_vname , &
                             idemix2_hrmsforc_file, idemix2_hrmsforc_vname, &
                             idemix2_hlamforc_file, idemix2_hlamforc_vname
    
    !___________________________________________________________________________
    ! CVMIX-IDEMIX variables
    
    ! M2 and niw frequency in 1/s
    real(kind=WP)                              :: iwe2_omega_M2 
    real(kind=WP), allocatable, dimension(:)   :: iwe2_omega_niw, iwe2_grady_coriol
    
    real(kind=WP)                              :: iwe2_dphit, iwe2_dphiu
    real(kind=WP), allocatable, dimension(:)   :: iwe2_phit, iwe2_phiu, aux
    
    real(kind=WP), allocatable, dimension(:,:) :: iwe2, iwe2_n, iwe2_tm1, iwe2_tm2
    real(kind=WP), allocatable, dimension(:,:) :: iwe2_M2, iwe2_M2_tm1, iwe2_M2_tm2
    real(kind=WP), allocatable, dimension(:,:) :: iwe2_niw, iwe2_niw_tm1, iwe2_niw_tm2
    
    real(kind=WP), allocatable, dimension(:,:) :: iwe2_M2_u, iwe2_M2_v, iwe2_M2_w
    real(kind=WP), allocatable, dimension(:,:) :: iwe2_niw_u, iwe2_niw_v, iwe2_niw_w
    
    real(kind=WP), allocatable, dimension(:)   :: iwe2_cn, iwe2_cg_M2, iwe2_cg_niw
    real(kind=WP), allocatable, dimension(:,:) :: iwe2_c0, iwe2_v0
    
    real(kind=WP), allocatable, dimension(:,:) :: iwe2_alpha_c, iwe2_alpha_c_n
    real(kind=WP), allocatable, dimension(:)   :: iwe2_alpha_M2_c
    
    real(kind=WP), allocatable, dimension(:)   :: iwe2_topo_hrms, iwe2_topo_hlam, iwe2_topo_dist, iwe2_topo_shelf
    real(kind=WP), allocatable, dimension(:)   :: iwe2_M2_tau, iwe2_niw_tau
    
    real(kind=WP), allocatable, dimension(:)   :: iwe2_fbot, iwe2_fsrf
    real(kind=WP), allocatable, dimension(:,:) :: iwe2_fM2, iwe2_fniw
    
    real(kind=WP), allocatable, dimension(:,:) :: iwe2_Av, iwe2_Kv
    
    real(kind=WP), allocatable, dimension(:,:) :: iwe2_Ttot, iwe2_Tdif, iwe2_Thdi, iwe2_Tdis, iwe2_Tdis_n, iwe2_Tsur, iwe2_Tbot
    
!     real(kind=WP), allocatable, dimension(:,:) :: cvmix_dummy_1, cvmix_dummy_2, cvmix_dummy_3
    
    real(kind=WP), allocatable, dimension(:,:) :: vol_wcelli
    
    ! load variables from CVMix list
    type(cvmix_data_type) :: CVMix_vars

    ! nils/
    integer :: tstep_count

    contains
    !
    !
    !
    !===========================================================================
    ! allocate and initialize IDEMIX variables --> call initialisation 
    ! routine from cvmix library
    subroutine init_cvmix_idemix2(partit, mesh)
        implicit none
        type(t_mesh),   intent(in),    target :: mesh
        type(t_partit), intent(inout), target :: partit
        
        character(len=cvmix_strlen) :: nmlfile
        logical                     :: file_exist=.False.
        integer                     :: node_size, elem_size, elem, nfbin, fbin_i, elnodes(3)
        real(kind=WP)               :: loc_Etot=0.0_WP, glb_Etot=0.0_WP
        real(kind=WP)               :: t0, t1
#include "../associate_part_def.h"
#include "../associate_mesh_def.h"
#include "../associate_part_ass.h"
#include "../associate_mesh_ass.h"
        !_______________________________________________________________________
        if(mype==0) then
            write(*,*) '____________________________________________________________'
            write(*,*) ' --> initialise IDEMIX2'
            write(*,*)
        end if
            
        !_______________________________________________________________________
        ! allocate + initialse idemix arrays --> with size myDim_nod2D+eDim_nod2D
        node_size=myDim_nod2D+eDim_nod2D
        elem_size=myDim_elem2D+eDim_elem2D
        nfbin    =idemix2_nfbin
        
        ! allocate dummy variable
        allocate(aux(elem_size))
        aux(:)              = 0.0_WP
        
        ! lat gradient in coriolis (is only computed @init)
        allocate(iwe2_grady_coriol(myDim_elem2D))
        iwe2_grady_coriol(:)= 0.0_WP
        
        allocate(iwe2_omega_niw(myDim_elem2D))
        iwe2_omega_niw(:)   = 0.0_WP
        
        ! allocate 1d Spectral space coordinates
        allocate(iwe2_phit(nfbin), iwe2_phiu(nfbin))
        iwe2_phit(:)        = 0.0_WP
        iwe2_phiu(:)        = 0.0_WP
        
        ! Internal wave energy at time levels
        allocate(iwe2(nl,elem_size), iwe2_tm1(nl,elem_size), iwe2_tm2(nl,elem_size), iwe2_n(nl,node_size))
        iwe2(:,:)           = 0.0_WP ! E_iw(t)
        iwe2_n(:,:)         = 0.0_WP ! E_iw(t)
        iwe2_tm1(:,:)       = 0.0_WP ! E_iw(t-1)
        iwe2_tm2(:,:)       = 0.0_WP ! E_iw(t-2)
        
        ! M2 wave energy at time levels
        allocate(iwe2_M2(nl,elem_size), iwe2_M2_tm1(nl,elem_size), iwe2_M2_tm2(nl,elem_size))
        iwe2_M2(:,:)        = 0.0_WP ! E_M2(t)
        iwe2_M2_tm1(:,:)    = 0.0_WP ! E_M2(t-1)
        iwe2_M2_tm2(:,:)    = 0.0_WP ! E_M2(t-2)
        
        ! niw wave energy at time levels
        allocate(iwe2_niw(nl,elem_size), iwe2_niw_tm1(nl,elem_size), iwe2_niw_tm2(nl,elem_size))
        iwe2_niw(:,:)       = 0.0_WP ! E_niw(t)
        iwe2_niw_tm1(:,:)   = 0.0_WP ! E_niw(t-1)
        iwe2_niw_tm2(:,:)   = 0.0_WP ! E_niw(t-2)
        
        ! internal wave related vertical viscosity and diffusivity
        allocate(iwe2_Av(nl,elem_size))
        allocate(iwe2_Kv(nl,elem_size))
        iwe2_Av(:,:)        = 0.0_WP
        iwe2_Kv(:,:)        = 0.0_WP
    
        allocate(vol_wcelli(nl,node_size))
        vol_wcelli(:,:)     = 0.0_WP        
        
        ! M2 group velocity components 
        allocate(iwe2_M2_u(nfbin,elem_size), iwe2_M2_v(nfbin,elem_size), iwe2_M2_w(nfbin,elem_size))
        iwe2_M2_u(:,:)      = 0.0_WP
        iwe2_M2_v(:,:)      = 0.0_WP
        iwe2_M2_w(:,:)      = 0.0_WP
        
        ! NIW group velocity components (i,j,np)
        allocate(iwe2_niw_u(nfbin,elem_size), iwe2_niw_v(nfbin,elem_size), iwe2_niw_w(nfbin,elem_size))
        iwe2_niw_u(:,:)     = 0.0_WP
        iwe2_niw_v(:,:)     = 0.0_WP
        iwe2_niw_w(:,:)     = 0.0_WP
        
        ! Vertical group velocity c0, Horizontal gfxaroup velocity v0
        allocate(iwe2_c0(nl,elem_size), iwe2_v0(nl,elem_size))
        iwe2_c0(:,:)        = 0.0_WP
        iwe2_v0(:,:)        = 0.0_WP
        
        allocate(iwe2_cg_M2(elem_size), iwe2_cg_niw(elem_size))
        iwe2_cg_M2(:)       = 0.0_WP
        iwe2_cg_niw(:)      = 0.0_WP
        
        allocate(iwe2_cn(node_size))
        iwe2_cn(:)          = 0.0_WP
        
        ! Dissipation coefficient
        allocate(iwe2_alpha_c(nl,elem_size), iwe2_alpha_c_n(nl,node_size), iwe2_alpha_M2_c(elem_size))
        iwe2_alpha_c(:,:)   = 0.0_WP
        iwe2_alpha_M2_c(:)  = 0.0_WP
        iwe2_alpha_c_n(:,:) = 0.0_WP
        
        ! forcing fields, M2 tidal forcing (spectral) and NIW forcing (spectral)
        allocate(iwe2_fbot(myDim_elem2D), iwe2_fsrf(myDim_elem2D))
        allocate(iwe2_fM2(nfbin, myDim_elem2D), iwe2_fniw(nfbin, myDim_elem2D))
        iwe2_fbot(:)        = 0.0_WP
        iwe2_fsrf(:)        = 0.0_WP
        iwe2_fM2(:,:)       = 0.0_WP
        iwe2_fniw(:,:)      = 0.0_WP
        
        ! Topographic height and Topographic wavelength
        allocate(iwe2_topo_hrms(myDim_elem2D), iwe2_topo_hlam(myDim_elem2D), iwe2_topo_shelf(myDim_elem2D), iwe2_topo_dist(myDim_elem2D))
        iwe2_topo_hrms(:)   = 0.0_WP
        iwe2_topo_hlam(:)   = 0.0_WP
        iwe2_topo_shelf(:)  = 0.0_WP
        iwe2_topo_dist(:)   = 0.0_WP
        
        ! M2 and NIW dissipation timescale
        allocate(iwe2_M2_tau(myDim_elem2D),iwe2_niw_tau(myDim_elem2D))
        iwe2_M2_tau(:)      = 0.0_WP
        iwe2_niw_tau(:)     = 0.0_WP
        
!         ! diagnostic 
!         allocate(iwe2_Ttot(nl,elem_size))
!         allocate(iwe2_Tdif(nl,elem_size))
!         allocate(iwe2_Thdi(nl,elem_size))
!         allocate(iwe2_Tdis(nl,elem_size), iwe2_Tdis_n(nl,node_size))
!         allocate(iwe2_Tsur(nl,elem_size))
!         allocate(iwe2_Tbot(nl,elem_size))
!         iwe2_Ttot(:,:)      = 0.0_WP
!         iwe2_Tdif(:,:)      = 0.0_WP
!         iwe2_Thdi(:,:)      = 0.0_WP
!         iwe2_Tdis(:,:)      = 0.0_WP
!         iwe2_Tsur(:,:)      = 0.0_WP
!         iwe2_Tbot(:,:)      = 0.0_WP
!         iwe2_Tdis_n(:,:)    = 0.0_WP
        
!         allocate(cvmix_dummy_1(nl,elem_size))
!         allocate(cvmix_dummy_2(nl,elem_size))
!         allocate(cvmix_dummy_3(nl,elem_size))
!         cvmix_dummy_1(:,:)  = 0.0_WP
!         cvmix_dummy_2(:,:)  = 0.0_WP
!         cvmix_dummy_3(:,:)  = 0.0_WP
        
        ! nils (for debugging)
        tstep_count  = 0
        
        !_______________________________________________________________________
        ! width of spectral frequency bins
        iwe2_dphit   = 2.0_WP*pi/(nfbin-2)
        iwe2_dphiu   = iwe2_dphit
        ! iwe2_phiu(k) represents the center of the k-th spectral bin
        ! iwe2_phit(k) represents the edge of the k-th spectral bin
        iwe2_phit(1) = -iwe2_dphit
        iwe2_phiu(1 )= iwe2_phit(1)+iwe2_dphit/2.0_WP
        do fbin_i=2,nfbin 
            iwe2_phit(fbin_i) = iwe2_phit(fbin_i-1) + iwe2_dphit
            iwe2_phiu(fbin_i) = iwe2_phiu(fbin_i-1) + iwe2_dphiu
        end do
        
        
        !_______________________________________________________________________
        ! read cvmix namelist file 
        nmlfile ='namelist.cvmix'    ! name of ocean namelist file
        ! check if cvmix namelist file exists if not use default values 
        file_exist=.False.
        inquire(file=trim(nmlfile),exist=file_exist) 
        if (file_exist) then
            open(20,file=trim(nmlfile))
                read(20,nml=param_idemix2)
            close(20)
        else
            write(*,*) '     could not find namelist.cvmix, will use default values !'    
        end if    
        
        
        !_______________________________________________________________________
        if (mype==0) then
            write(*,*) "     IDEMIX2 parameters:"
            write(*,*) "     ├> idemix2_tau_v              = ", idemix2_tau_v
            write(*,*) "     ├> idemix2_tau_h              = ", idemix2_tau_h
            write(*,*) "     ├> idemix2_gamma              = ", idemix2_gamma
            write(*,*) "     ├> idemix2_jstar              = ", idemix2_jstar
            write(*,*) "     ├> idemix2_mu0                = ", idemix2_mu0
            write(*,*) "     │                               "
            write(*,*) "     ├> idemix2_superbee_adv       = ", idemix2_enable_superbee_adv
            write(*,*) "     ├> idemix2_AB_timestep        = ", idemix2_enable_AB_timestep
            write(*,*) "     ├> idemix2_nfbin              = ", idemix2_nfbin
            write(*,*) "     │                               "
            write(*,*) "     ├> idemix2_enable_M2          = ", idemix2_enable_M2
            write(*,*) "     │  └> idemix2_M2forc_file     = ", trim(idemix2_M2forc_file)
            write(*,*) "     │     └> idemix2_M2forc_vname = ", trim(idemix2_M2forc_vname)
            write(*,*) "     │                               "
            write(*,*) "     ├> idemix2_enable_niw         = ", idemix2_enable_niw 
            write(*,*) "     │  ├> idemix2_fniw_usage      = ", idemix2_fniw_usage 
            write(*,*) "     │  └> idemix2_niwforc_file    = ", trim(idemix2_niwforc_file)
            write(*,*) "     │     └> idemix2_niwforc_vname= ", trim(idemix2_niwforc_vname)
            write(*,*) "     │                               "
            write(*,*) "     ├> idemix2_botforc_file       = ", trim(idemix2_botforc_file)
            write(*,*) "     │  ├> idemix2_botforc_vname   = ", trim(idemix2_botforc_vname)
            write(*,*) "     │  └> idemix2_botforc_Etot    = ", idemix2_botforc_Etot
            write(*,*) "     │                               "
            write(*,*) "     ├> idemix2_hrmsforc_file      = ", trim(idemix2_hrmsforc_file)
            write(*,*) "     │  └> idemix2_hrmsforc_vname  = ", trim(idemix2_hrmsforc_vname)
            write(*,*) "     │                               "
            write(*,*) "     ├> idemix2_hlamforc_file      = ", trim(idemix2_hlamforc_file)
            write(*,*) "     │  └> idemix2_hlamforc_vname  = ", trim(idemix2_hlamforc_vname)
            write(*,*) "     │                               "
            WRITE(*,*) "     └> idemix2_shelf_dist         = ", idemix2_shelf_dist
            write(*,*)
            write(*,*) "     IDEMIX2 inputs:"
        end if
        
        
        !_______________________________________________________________________
        ! read idemix M2 forcing from cfsr data --> file 
        if (idemix2_enable_M2) then
            t0=MPI_Wtime()
            ! omega_M2 is fixed, as the M2 tidal forcing is independent of the local inertial frequency.
            ! Physical Implication: At high latitudes where |f| > ω_M2, the M2 tide becomes evanescent 
            ! (cannot propagate as internal waves). This is handled in the code by checking ω_M2 > |f| 
            ! for M2 tidal forcing when computing iwe_M2_tau, if  ω_M2 < |f| --> iwe_M2_tau=0.0
            iwe2_omega_M2 =  2*pi/( 12*60*60 + 25.2 *60 )   ! M2 frequency in 1/s
            
            file_exist=.False.
            inquire(file=trim(idemix2_M2forc_file),exist=file_exist) 
            if (file_exist) then
                if (mype==0) write(*,*) '     ├> read IDEMIX2 M2 wave forcing'
                do fbin_i =2, nfbin-1
                    call read_other_NetCDF(trim(idemix2_M2forc_file), trim(idemix2_M2forc_vname), fbin_i, aux, .true., .false., partit, mesh)
                    !                                                                                                     |           
                    !                                    .false.=interpolate on element centroids instead of vertices <---+   
                    iwe2_fM2(fbin_i, :) = aux/density_0/iwe2_dphit
                end do  
                deallocate(aux)
            else
                if (mype==0) then
                    print *, achar(27)//'[33m'
                    write(*,*) '____________________________________________________________________'
                    write(*,*) ' ERROR: IDEMIX2 M2 forcing file not found! Cant apply IDEMIX2'
                    write(*,*) '        vertical mixing parameterisation! '
                    write(*,*) '        ├> file: ', trim(idemix2_M2forc_file)
                    write(*,*) '        └> check: namelist.cvmix, idemix2_M2forc_file &  '
                    write(*,*) '____________________________________________________________________'
                    print *, achar(27)//'[0m'
                    write(*,*)
                    call par_ex(partit%MPI_COMM_FESOM, partit%mype, 0)
                end if
            end if 
            t1=MPI_Wtime()
            if (mype==0) write(*,*) '     |  └> elapsed time:', t1-t0
        end if ! --> if (idemix2_enable_M2) then
        
        
        !_______________________________________________________________________
        ! read idemix niw oe srf forcing from cfsr data --> file 
        t0=MPI_Wtime()
        file_exist=.False.
        inquire(file=trim(idemix2_niwforc_file),exist=file_exist) 
        if (file_exist) then
            
            call read_other_NetCDF(trim(idemix2_niwforc_file), trim(idemix2_niwforc_vname), 1, iwe2_fsrf, .true., .false., partit, mesh)
            ! only 20% (idemix2_fniw_usage) from the surface forcing goes into internal waves
            ! iwe2_fsrf becomes surface forcing variable when idemix2_enable_niw=.false.
            ! in this case standard idemix1 behaviour 
            iwe2_fsrf = iwe2_fsrf/density_0*idemix2_fniw_usage
            if (idemix2_enable_niw) then
                if (mype==0) write(*,*) '     ├> read IDEMIX2 niw wave forcing'
                do fbin_i =2, nfbin-1
                    iwe2_fniw(fbin_i, :) = iwe2_fsrf/iwe2_dphit !!!ATTENTION CHECK THIS AGAIN!!!
                end do 
                iwe2_fsrf(:) = 0.0_WP
            else
                if (mype==0) write(*,*) '     ├> read IDEMIX2 surface wave forcing'
            end if
            
        else
            if (mype==0) then
                print *, achar(27)//'[33m'
                write(*,*) '____________________________________________________________________'
                write(*,*) ' ERROR: IDEMIX2 NIW forcing file not found! Cant apply IDEMIX2'
                write(*,*) '        vertical mixing parameterisation! '
                write(*,*) '        ├> file: ', trim(idemix2_niwforc_file)
                write(*,*) '        └> check: namelist.cvmix, idemix2_niwforc_file &  '
                write(*,*) '____________________________________________________________________'
                print *, achar(27)//'[0m'
                write(*,*)
                call par_ex(partit%MPI_COMM_FESOM, partit%mype, 0)
            end if
        end if 
        
        ! NIWs are super-inertial (ω_niw > |f|), which is essential for their propagation as internal waves.
        ! The factor 1.05 ensures the frequency is 5% above the local inertial frequency.
        ! Why 1.05? Represents the minimum frequency for NIWs to propagate. Accounts for the Doppler shift 
        ! from background flows. Physical Context: NIWs are generated by wind events and have frequencies 
        ! close to f. They can only propagate as internal waves if ω > |f|.
        if (idemix2_enable_niw) then
            do elem = 1, myDim_elem2D
                iwe2_omega_niw(elem) = max(1d-8, abs( 1.05 * mesh%coriolis(elem) ) )
            end do
            call exchange_elem(iwe2_omega_niw, partit)
        end if 
        t1=MPI_Wtime()
        if (mype==0) write(*,*) '     |  └> elapsed time:', t1-t0
        
        !_______________________________________________________________________
        ! read idemix bottom near tidal forcing from cesm data set --> file 
        ! from N. Brüggemann interpoalted to regular grid
        t0=MPI_Wtime()
        file_exist=.False.
        inquire(file=trim(idemix2_botforc_file),exist=file_exist) 
        if (file_exist) then
            if (mype==0) write(*,*) '     ├> read IDEMIX2 near tidal bottom forcing'
            call read_other_NetCDF(trim(idemix2_botforc_file), trim(idemix2_botforc_vname), 1, iwe2_fbot, .true., .false., partit, mesh)
            !                                                                                                  |           
            !                                 .false.=interpolate on element centroids instead of vertices <---+   
            
            ! check for total tidal energy that is infused through the bottom, see how 
            ! much is lossed during interpolation and compare with value of the 
            ! original files
            loc_Etot = 0.0_WP
            do elem=1, myDim_elem2D
                ! REMEMBER!!!: the partition on elements is not unique there are 
                ! elements that belong to two CPUs. For unique elements the index
                ! of the First trinagle node must  be <= myDim_nod2D
                if (elem2D_nodes(1,elem)<=myDim_nod2D) then
                    loc_Etot = loc_Etot + elem_area(elem)*iwe2_fbot(elem)
                end if     
            end do
            call MPI_AllREDUCE(loc_Etot, glb_Etot, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_FESOM, MPIerr)
            if (mype==0) write(*,*) "     │  └> IDEMIX2 total tidal energy Etot_bot =", glb_Etot*1.0e-12, ' TW'
            
            ! normalize total tidal energy at bottom with respect to the total 
            ! tidal energy that is e.g in the original forcing files to accomodate 
            ! non concerving losses during interpolation. This is only done when 
            ! in namelist.cvmix: idemix2_botforc_Etot \= 0.0_WP
            if (idemix2_botforc_Etot /= 0.0_WP) then
                iwe2_fbot = iwe2_fbot * idemix2_botforc_Etot/glb_Etot
                
                loc_Etot = 0.0_WP
                do elem=1, myDim_elem2D
                    ! REMEMBER!!!: the partition on elements is not unique there are 
                    ! elements that belong to two CPUs. For unique elements the index
                    ! of the First trinagle node must  be <= myDim_nod2D
                    if (elem2D_nodes(1,elem)<=myDim_nod2D) then
                        loc_Etot = loc_Etot + elem_area(elem)*iwe2_fbot(elem)
                    end if     
                end do
                call MPI_AllREDUCE(loc_Etot, glb_Etot, 1, MPI_DOUBLE_PRECISION, MPI_SUM, MPI_COMM_FESOM, MPIerr)
                if (mype==0) write(*,*) "     │  └> IDEMIX2 Etot_bot after normalizing =", glb_Etot*1.0e-12, ' TW'
            end if 
            
            ! divide by density_0 --> convert from W/m^2 to m^3/s^3
            iwe2_fbot  = iwe2_fbot/density_0
            
        else
            if (mype==0) then
                print *, achar(27)//'[33m'
                write(*,*) '____________________________________________________________________'
                write(*,*) ' ERROR: IDEMIX2 bottom forcing file not found! Cant apply IDEMIX'
                write(*,*) '        vertical mixing parameterisation! '
                write(*,*) '        ├> file: ', trim(idemix2_botforc_file)
                write(*,*) '        └> check: namelist.cvmix, idemix2_botforc_file'
                write(*,*) '____________________________________________________________________'
                print *, achar(27)//'[0m'
                write(*,*)
                call par_ex(partit%MPI_COMM_FESOM, partit%mype, 0)
            end if 
        end if 
        t1=MPI_Wtime()
        if (mype==0) write(*,*) '     │  └> elapsed time:', t1-t0
        
        !_______________________________________________________________________
        ! read idemix HRMS and HLAM forcing --> file 
        if (idemix2_enable_M2 .or. idemix2_enable_niw ) then
            t0=MPI_Wtime()
            ! topo_hrms (Root Mean Square Topographic Height), Definition: Measures the roughness or variability of seafloor topography.
            ! Units: Meters (m), Role: Represents the standard deviation of seafloor height variations. Used to calculate 
            ! energy transfer from tides/NIW to internal waves.
            ! file_exist=.False.
            inquire(file=trim(idemix2_hrmsforc_file),exist=file_exist) 
            if (file_exist) then
                if (mype==0) write(*,*) '     ├> read IDEMIX2 HRMS forcing'
                call read_other_NetCDF(trim(idemix2_hrmsforc_file), trim(idemix2_hrmsforc_vname), 1, iwe2_topo_hrms, .true., .false., partit, mesh)
            else
                if (mype==0) then
                    print *, achar(27)//'[33m'
                    write(*,*) '____________________________________________________________________'
                    write(*,*) ' ERROR: IDEMIX2 HRMS forcing file not found! Cant apply IDEMIX2'
                    write(*,*) '        vertical mixing parameterisation! '
                    write(*,*) '        ├> file: ', trim(idemix2_hrmsforc_file)
                    write(*,*) '        └> check: namelist.cvmix, idemix2_hrmsforc_file'
                    write(*,*) '____________________________________________________________________'
                    print *, achar(27)//'[0m'
                    write(*,*)
                    call par_ex(partit%MPI_COMM_FESOM, partit%mype, 0)
                end if
            end if 
            
            ! topo_hlam (Topographic Wavelength), Definition: Characteristic horizontal length scale of topographic features.
            ! Units: Meters (m), Role: Represents the dominant wavelength of seafloor roughness. Used to normalize the topographic forcing.
            file_exist=.False.
            inquire(file=trim(idemix2_hlamforc_file),exist=file_exist) 
            if (file_exist) then
                if (mype==0) write(*,*) '     ├> read IDEMIX2 HLAM forcing'
                call read_other_NetCDF(trim(idemix2_hlamforc_file), trim(idemix2_hlamforc_vname), 1, iwe2_topo_hlam, .true., .false., partit, mesh)
            else
                if (mype==0) then
                    print *, achar(27)//'[33m'
                    write(*,*) '____________________________________________________________________'
                    write(*,*) ' ERROR: IDEMIX2 HLAM forcing file not found! Cant apply IDEMIX2'
                    write(*,*) '        vertical mixing parameterisation! '
                    write(*,*) '        ├> file: ', trim(idemix2_hlamforc_file)
                    write(*,*) '        └> check: namelist.cvmix, idemix2_hlamforc_file'
                    write(*,*) '____________________________________________________________________'
                    print *, achar(27)//'[0m'
                    write(*,*)
                    call par_ex(partit%MPI_COMM_FESOM, partit%mype, 0)
                end if
            end if 
            
            ! In the M2 tidal and NIW energy calculations:
            !  --> fxc = topo_hrms(i,j)**2 * 2*pi / (1d-12 + topo_lam(i,j))
            ! This term estimates the energy flux from barotropic tides to internal waves. The ratio topo_hrms²/topo_lam represents 
            ! the topographic "steepness" affecting wave generation.
            ! Physical Interpretation: 
            !  --> High topo_hrms and small topo_lam: Indicates rough, steep topography that efficiently generates internal waves. 
            !  --> Low topo_hrms and large topo_lam: Indicates smooth, flat topography with minimal wave generation.
            ! These parameters are crucial for accurately representing the conversion of barotropic tidal energy to internal 
            ! waves over rough topography.
            
            t1=MPI_Wtime()
            if (mype==0) write(*,*) '     |  └> elapsed time:', t1-t0
        
        end if ! --> if (idemix2_enable_niw) then
        
        !_______________________________________________________________________
        ! compute centroid distance from nearset coastal point together with
        ! idemix2_shelf_dist defines what is shelf and what not  
        t0=MPI_Wtime() 
        call compute_dist2coast(iwe2_topo_dist, mesh, partit, 'elem')
        t1=MPI_Wtime()
        if (partit%mype==0) write(*,*) '        └> dist2coast elapsed time:', t1-t0
        
        !_______________________________________________________________________
        ! compute d/dy of coriolis 
        do elem = 1, myDim_elem2D
            elnodes = elem2d_nodes(:,elem)
            iwe2_grady_coriol(elem) = sum(gradient_sca(4:6, elem)*mesh%coriolis_node(elnodes))
        end do       
        
        !_______________________________________________________________________
        ! initialise IDEMIX parameters
        call cvmix_init_idemix2(tau_v               = idemix2_tau_v               , &
                                tau_h               = idemix2_tau_h               , &
                                gamma               = idemix2_gamma               , &
                                jstar               = idemix2_jstar               , &
                                mu0                 = idemix2_mu0                 , &
                                nfbin               = idemix2_nfbin               , &   
                                shelf_dist          = idemix2_shelf_dist          , &
                                enable_M2           = idemix2_enable_M2           , &
                                enable_niw          = idemix2_enable_niw          , & 
                                enable_superbee_adv = idemix2_enable_superbee_adv , &
                                enable_AB_timestep  = idemix2_enable_AB_timestep  , &
                                enable_hor_diffusion= idemix2_enable_hor_diffusion, &
                                hor_diffusion_niter = idemix2_hor_diffusion_niter   &
                                )
                                
        if (partit%mype==0) write(*,*)                  
    end subroutine init_cvmix_idemix2
    
    !
    !
    !
    !===========================================================================
    ! calculate IDEMIX2 internal wave energy and its dissipation
    subroutine calc_cvmix_idemix2(partit, mesh)   
        implicit none
        type(t_mesh),   intent(in),    target :: mesh
        type(t_partit), intent(inout), target :: partit
        integer       :: node, elem, edge, node_size, elem_size, k
        integer       :: nz, nln, nl1, nl2, nl12, nu1, nu2, nu12, uln, niter  
        integer       :: elnodes1(3), elnodes2(3), el(2), ednodes(2) 
        real(kind=WP) :: dz_trr(mesh%nl), dz_trr2(mesh%nl), bvfreq2(mesh%nl), vflux, dz_el, aux, cflfac
        real(kind=WP) :: grad_v0Eiw(2), lat_e_deg, deltaX1, deltaY1, deltaX2, deltaY2
        real(kind=WP) :: tsum1, tsum2, tsum3, tsum4, tvol
        real(kind=WP) :: cn, cn_e, cn_gradx_e, cn_grady_e
        logical       :: debug=.false.

#include "../associate_part_def.h"omega_M2
#include "../associate_mesh_def.h"
#include "../associate_part_ass.h"
#include "../associate_mesh_ass.h"
        ! nils
        !tstep_count = tstep_count + 1
        node_size = myDim_nod2D
        elem_size = myDim_elem2D
        
        !_______________________________________________________________________
        ! compute baroclinic gravity wave speed 
        do node=1, node_size
            nln = mesh%nl
            uln = 1
            do nz=1, nod_in_elem2D_num(node)
                nln=min(nln, nlevels(nod_in_elem2D(nz, node)))
                uln=max(uln, ulevels(nod_in_elem2D(nz, node)))
            end do
            cn=0.0_WP
            do nz=uln, nln-1
                cn=cn+hnode_new(nz,node)*(sqrt(max(bvfreq(nz,node), 0._WP))+sqrt(max(bvfreq(nz+1,node), 0._WP)))/2._WP
            end do
            iwe2_cn(node)=cn/pi
        end do
        call exchange_elem(iwe2_cn, partit)
        
        
        !_______________________________________________________________________
        do elem = 1,elem_size
            nln = nlevels(elem)-1
            uln = ulevels(elem)
            elnodes1 = elem2d_nodes(:,elem)
            
            lat_e_deg = sum(geo_coord_nod2D(2,elnodes1))/3.0 * 180.0/pi    
            
            !___________________________________________________________________
            ! calculate for TKE square of Brünt-Väisälä frequency, be aware that
            ! bvfreq contains already the squared brünt Väisälä frequency ...
            bvfreq2          = 0.0_WP
            do nz= uln, nln+1 
                bvfreq2(nz)  = sum(bvfreq(nz,elnodes1))/3.0_WP
            end do
            
            !___________________________________________________________________
            ! dz_trr distance between tracer points, surface and bottom dz_trr is half 
            ! the layerthickness ...
            dz_trr           = 0.0_WP
            dz_trr(uln+1:nln)= helem(uln:nln-1,elem)*0.5_WP + helem(uln+1:nln,elem)*0.5_WP
            dz_trr(uln)      = helem(uln,elem)*0.5_WP
            dz_trr(nln+1)    = helem(nln,elem)*0.5_WP
            
            !___________________________________________________________________
            ! compute baroclionic gravity wave speed on elements
            cn_e = sum(iwe2_cn(elnodes1))/3.0
            
            ! compute gradient of  baroclionic gkdot_x_M2 = sqrt(fxa)/omega_M2*cn_gradxravity wave speed on elements
            cn_gradx_e = sum(gradient_sca(1:3,elem)*iwe2_cn(elnodes1))
            cn_grady_e = sum(gradient_sca(4:6,elem)*iwe2_cn(elnodes1))
            
            !___________________________________________________________________
            ! 1st. compute idemix2 parameter over the vertical water column and 
            ! local horizontal parameters on elements !!!:  
            !  IN VARIABLES:
            ! --------------
            ! nlev      ... number of mid-depth levels
            ! nfbin     ... number of spectral bins used for the M2 tidal and 
            !               near-inertial wave (niw)
            ! dtime     ... time step
            ! coriolis  ... coriolis parameter 
            ! grady_coriol ... lat gradient of coriolis paramter
            ! coslat    ... cosine of latitude @elem
            ! Nsqr      ... squared buoyancy frequency
            ! omega_M2  ... M2 frequency (fixed)
            ! omega_niw ... NIW frequency (lat dependent)
            ! cn        ... baroclionic gravity wave speed
            ! cn_gradx  ... zonal gradient of  baroclionic gravity wave speed
            ! cn_grady  ... merid gradient of  baroclionic gravity wave speed
            ! phit      ... edge of the k-th spectral bin
            ! phiu      ... center of the k-th spectral bin
            ! 
            ! OUT VARIABLES:
            ! --------------
            ! alpha_c   ... 3d enery dissipation coefficient 
            ! c0        ... 3d horizontal group velocities (m/s) for the continuous 
            !              z internal wave spectrum
            ! v0        ... 3d vertical group velocities (m/s) for the continuous 
            !               internal wave spectrum
            ! cg_M2     ... 2d group velocity of M2 internal tidal waves 
            ! cg_niw    ... 2d group velocity of near-inertial waves (NIW)
            ! u_M2      ... zonal component of M2 internal tide group velocity
            ! v_M2      ... meridional component of M2 internal tide group velocity
            ! w_M2      ... vertical component of M2 internal tide group velocity
            ! u_niw     ... zonal component of NIW internal group velocity
            ! v_niw     ... meridional component of NIW internal group velocity
            ! w_niw     ... vertical component of NIW internal group velocity
            call cvmix_compute_groupvel_idemix2(               &
                nlev        = nln-uln+1                   , & !IN 
                nfbin       = idemix2_nfbin               , & !IN
                dtime       = dt                          , & !IN 
                coriolis    = mesh%coriolis(        elem) , & !IN 
                grady_coriol= iwe2_grady_coriol(    elem) , & !IN
                coslat      = mesh%elem_cos(        elem) , & !IN
                Nsqr        = bvfreq2(     uln:nln      ) , & !IN
                omega_M2    = iwe2_omega_M2               , & !IN
                omega_niw   = iwe2_omega_niw(       elem) , & !IN
                cn          = cn_e                        , & !IN
                cn_gradx    = cn_gradx_e                  , & !IN
                cn_grady    = cn_grady_e                  , & !IN
                phit        = iwe2_phit                   , & !IN 
                phiu        = iwe2_phiu                   , & !IN 
                alpha_c     = iwe2_alpha_c(uln:nln, elem) , & !OUT
                c0          = iwe2_c0(     uln:nln, elem) , & !OUT
                v0          = iwe2_v0(     uln:nln, elem) , & !OUT
                cg_M2       = iwe2_cg_M2(           elem) , & !OUT
                cg_niw      = iwe2_cg_niw(          elem) , & !OUT
                u_M2        = iwe2_M2_u(         :, elem) , & !OUT
                v_M2        = iwe2_M2_v(         :, elem) , & !OUT
                w_M2        = iwe2_M2_w(         :, elem) , & !OUT
                u_niw       = iwe2_niw_u(        :, elem) , & !OUT
                v_niw       = iwe2_niw_v(        :, elem) , & !OUT
                w_niw       = iwe2_niw_w(        :, elem)   & !OUT
                )
                
            !___________________________________________________________________
            ! 2st. compute dissipation time scales and rates
            !  IN VARIABLES:
            ! --------------
            ! dtime     ... time step
            ! lat       ... elem lat coordinates
            ! coriolis  ... coriolis parameter 
            ! omega_M2  ... M2 frequency (fixed)
            ! omega_niw ... NIW frequency (lat dependent)
            ! cn        ... baroclionic gravity wave speed
            ! zbottom   ... bottom depth at elements
            ! topo_hrms ... root mean square topographic height
            ! topo_hlam ... characteristic horiz. length scale of topographic features
            ! topo_shelf... point is considered shelf
            ! 
            ! OUT VARIABLES:
            ! --------------
            ! tau_M2    ... M2 Tidal Dissipation Timescale     
            ! tau_niw   ... NIW Dissipation Timescale
            ! alpha_M2_cont... M2 Continuous Dissipation Rate (Background M2 tidal 
            !                  dissipation rate
            call cvmix_compute_interact_tscale_idemix2(     &
                dtime       = dt                          , & !IN 
                lat         = lat_e_deg                   , & !IN
                coriolis    = mesh%coriolis(        elem) , & !IN 
                omega_M2    = iwe2_omega_M2               , & !IN
                omega_niw   = iwe2_omega_niw(       elem) , & !IN
                cn          = cn_e                        , & !IN
                zbottom     = zbar_e_bot(           elem) , & !IN
                topo_hrms   = iwe2_topo_hrms(       elem) , & !IN
                topo_hlam   = iwe2_topo_hlam(       elem) , & !IN
                topo_shelf  = iwe2_topo_shelf(      elem) , & !IN
                tau_M2      = iwe2_M2_tau(          elem) , & !OUT
                tau_niw     = iwe2_niw_tau(         elem) , & !OUT
                alpha_M2_c  = iwe2_alpha_M2_c(      elem)   & !OUT
            )
            !___________________________________________________________________
        end do ! --> do elem = 1,elem_size    
            
    end subroutine calc_cvmix_idemix2    

end module g_cvmix_idemix2