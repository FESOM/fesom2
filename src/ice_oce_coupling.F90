module ocean2ice_interface
    interface
        subroutine ocean2ice(ice, dynamics, tracers, partit, mesh)
        USE MOD_ICE
        USE MOD_DYN
        USE MOD_TRACER
        USE MOD_PARTIT
        USE MOD_PARSUP
        USE MOD_MESH
        type(t_ice)   , intent(inout), target :: ice
        type(t_dyn)   , intent(in)   , target :: dynamics
        type(t_tracer), intent(inout), target :: tracers
        type(t_partit), intent(inout), target :: partit
        type(t_mesh)  , intent(in)   , target :: mesh
        end subroutine
    end interface
end module

module oce_fluxes_interface
    interface
        subroutine oce_fluxes(ice, dynamics, tracers, partit, mesh)
        USE MOD_ICE
        USE MOD_DYN
        USE MOD_TRACER
        USE MOD_PARTIT
        USE MOD_PARSUP
        USE MOD_MESH
        type(t_ice)   , intent(inout), target :: ice
        type(t_dyn)   , intent(in)   , target :: dynamics
        type(t_tracer), intent(inout), target :: tracers
        type(t_partit), intent(inout), target :: partit
        type(t_mesh)  , intent(in)   , target :: mesh
        end subroutine
        
        subroutine oce_fluxes_mom(ice, dynamics, partit, mesh)
        USE MOD_ICE
        USE MOD_DYN
        USE MOD_PARTIT
        USE MOD_PARSUP
        USE MOD_MESH
        type(t_ice)   , intent(inout), target :: ice
        type(t_dyn)   , intent(in)   , target :: dynamics
        type(t_partit), intent(inout), target :: partit
        type(t_mesh)  , intent(in)   , target :: mesh
        end subroutine
    end interface
end module

!
!
!_______________________________________________________________________________
! transmits the relevant fields from the ice to the ocean model
subroutine oce_fluxes_mom(ice, dynamics, partit, mesh)
    USE MOD_ICE
    USE MOD_DYN
    USE MOD_PARTIT
    USE MOD_PARSUP
    USE MOD_MESH
    use o_PARAM
    use o_ARRAYS
    USE g_CONFIG
    use g_comm_auto
#if defined (__icepack)
    use icedrv_main,   only: icepack_to_fesom
#endif
    implicit none
    type(t_ice)   , intent(inout), target :: ice
    type(t_dyn)   , intent(in)   , target :: dynamics
    type(t_partit), intent(inout), target :: partit
    type(t_mesh)  , intent(in)   , target :: mesh
    !___________________________________________________________________________
    integer                  :: n, elem, elnodes(3),n1
    real(kind=WP)            :: aux
    !___________________________________________________________________________
    ! pointer on necessary derived types
    real(kind=WP), dimension(:), pointer  :: u_ice, v_ice, a_ice, u_w, v_w
    real(kind=WP), dimension(:), pointer  :: stress_iceoce_x, stress_iceoce_y  
#include "associate_part_def.h"
#include "associate_mesh_def.h"
#include "associate_part_ass.h"
#include "associate_mesh_ass.h"
    u_ice           => ice%uice(:)
    v_ice           => ice%vice(:)
    a_ice           => ice%data(1)%values(:)
    u_w             => ice%srfoce_u(:)
    v_w             => ice%srfoce_v(:)
    stress_iceoce_x => ice%stress_iceoce_x(:)
    stress_iceoce_y => ice%stress_iceoce_y(:)
  
    ! ==================
    ! momentum flux:
    ! ==================
    !___________________________________________________________________________

#if defined (__icepack)
     call icepack_to_fesom(nx_in=(myDim_nod2D+eDim_nod2D), &
                           aice_out=a_ice)
#endif
    !___________________________________________________________________________
    ! compute total surface stress (iceoce+atmoce) on nodes 

!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(n, elem, elnodes, n1, aux)
!$OMP DO
    do n=1,myDim_nod2D+eDim_nod2D   
        !_______________________________________________________________________
        ! if cavity node skip it 
        if (ulevels_nod2d(n)>1) cycle
        
        !_______________________________________________________________________
        if(a_ice(n)>0.001_WP) then
            aux=sqrt((u_ice(n)-u_w(n))**2+(v_ice(n)-v_w(n))**2)*density_0*ice%cd_oce_ice
            stress_iceoce_x(n) = aux * (u_ice(n)-u_w(n))
            stress_iceoce_y(n) = aux * (v_ice(n)-v_w(n))
        else
            stress_iceoce_x(n)=0.0_WP
            stress_iceoce_y(n)=0.0_WP
        end if
        
        stress_node_surf(1,n) = stress_iceoce_x(n)*a_ice(n) + stress_atmoce_x(n)*(1.0_WP-a_ice(n))
        stress_node_surf(2,n) = stress_iceoce_y(n)*a_ice(n) + stress_atmoce_y(n)*(1.0_WP-a_ice(n))
    end do
!$OMP END DO
    !___________________________________________________________________________
    ! compute total surface stress (iceoce+atmoce) on elements
!$OMP DO
    DO elem=1,myDim_elem2D
        !_______________________________________________________________________
        ! if cavity element skip it 
        if (ulevels(elem)>1) cycle
        
        !_______________________________________________________________________
        elnodes=elem2D_nodes(:,elem)
        stress_surf(1,elem)=sum(stress_iceoce_x(elnodes)*a_ice(elnodes) + &
                                stress_atmoce_x(elnodes)*(1.0_WP-a_ice(elnodes)))/3.0_WP
        stress_surf(2,elem)=sum(stress_iceoce_y(elnodes)*a_ice(elnodes) + &
                                stress_atmoce_y(elnodes)*(1.0_WP-a_ice(elnodes)))/3.0_WP
    END DO
!$OMP END DO
!$OMP END PARALLEL
    !___________________________________________________________________________
    if (use_cavity) call cavity_momentum_fluxes(dynamics, partit, mesh)
  
end subroutine oce_fluxes_mom
!
!
!_______________________________________________________________________________
! transmits the relevant fields from the ocean to the ice model
subroutine ocean2ice(ice, dynamics, tracers, partit, mesh)
    USE MOD_ICE
    USE MOD_DYN
    USE MOD_TRACER
    USE MOD_PARTIT
    USE MOD_PARSUP
    USE MOD_MESH
    use o_PARAM
    use g_CONFIG
    use g_comm_auto
    implicit none
    type(t_ice)   , intent(inout), target :: ice
    type(t_dyn)   , intent(in)   , target :: dynamics
    type(t_tracer), intent(inout), target :: tracers
    type(t_partit), intent(inout), target :: partit
    type(t_mesh),   intent(in),    target :: mesh
    integer :: n, elem, k
    real(kind=WP) :: uw, vw, vol
    real(kind=WP), dimension(:,:)  , pointer :: temp, salt
    real(kind=WP), dimension(:,:,:), pointer :: UV
    real(kind=WP), dimension(:)    , pointer :: S_oc_array, T_oc_array, u_w, v_w, elevation
#include "associate_part_def.h"
#include "associate_mesh_def.h"
#include "associate_part_ass.h"
#include "associate_mesh_ass.h"
    temp       => tracers%data(1)%values(:,:)
    salt       => tracers%data(2)%values(:,:)
    UV         => dynamics%uv(:,:,:)
    u_w        => ice%srfoce_u(:)
    v_w        => ice%srfoce_v(:)
    T_oc_array => ice%srfoce_temp(:)
    S_oc_array => ice%srfoce_salt(:)
    elevation  => ice%srfoce_ssh(:)
    
    !___________________________________________________________________________
    ! the arrays in the ice model are renamed
!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(n, elem, k, uw, vw, vol)
     if (ice%ice_update) then
!$OMP DO
        do n=1, myDim_nod2d+eDim_nod2d  
            if (ulevels_nod2D(n)>1) cycle 
            T_oc_array(n) = temp(1,n)
            S_oc_array(n) = salt(1,n)
            elevation(n)  = hbar(n)
        end do
!$OMP END DO
    else
!$OMP DO
        do n=1, myDim_nod2d+eDim_nod2d
            if (ulevels_nod2D(n)>1) cycle 
             T_oc_array(n) = (T_oc_array(n)*real(ice%ice_steps_since_upd,WP)+temp(1,n))/real(ice%ice_steps_since_upd+1,WP)
             S_oc_array(n) = (S_oc_array(n)*real(ice%ice_steps_since_upd,WP)+salt(1,n))/real(ice%ice_steps_since_upd+1,WP)
             elevation(n)  = (elevation(n) *real(ice%ice_steps_since_upd,WP)+  hbar(n))/real(ice%ice_steps_since_upd+1,WP)
        end do
!$OMP END DO
    end if

!$OMP DO
    do n=1, myDim_nod2d+eDim_nod2d
       u_w(n) = 0.0_WP
       v_w(n) = 0.0_WP
    end do
!$OMP END DO

!$OMP DO
    do n=1, myDim_nod2d  
        if (ulevels_nod2D(n)>1) cycle 
        uw  = 0.0_WP
        vw  = 0.0_WP
        vol = 0.0_WP
        do k=1, nod_in_elem2D_num(n)
            elem=nod_in_elem2D(k,n)
            if (ulevels(elem)>1) cycle
            vol = vol + elem_area(elem)
            uw  = uw+ UV(1,1,elem)*elem_area(elem)
            vw  = vw+ UV(2,1,elem)*elem_area(elem)
        end do
        uw = uw/vol
        vw = vw/vol
        
        if (ice%ice_update) then
            u_w(n)=uw
            v_w(n)=vw
        else
            u_w(n)=(u_w(n)*real(ice%ice_steps_since_upd,WP)+uw)/real(ice%ice_steps_since_upd+1,WP)
            v_w(n)=(v_w(n)*real(ice%ice_steps_since_upd,WP)+vw)/real(ice%ice_steps_since_upd+1,WP)
        endif
    end do
!$OMP END DO
!$OMP END PARALLEL
    call exchange_nod(u_w, v_w, partit)
end subroutine ocean2ice
!
!
!_______________________________________________________________________________
subroutine oce_fluxes(ice, dynamics, tracers, partit, mesh)
    USE MOD_ICE
    USE MOD_DYN
    USE MOD_TRACER
    USE MOD_PARTIT
    USE MOD_PARSUP
    USE MOD_MESH
    use g_CONFIG
    use o_ARRAYS
    use g_comm_auto
    use g_forcing_param, only: use_virt_salt
    use g_forcing_arrays
    use g_support
    use cavity_interfaces
#if defined (__icepack)
    use icedrv_main,   only: icepack_to_fesom,    &
                            init_flux_atm_ocn
#endif
    use cavity_interfaces
    implicit none
    type(t_ice)   , intent(inout), target :: ice
    type(t_dyn)   , intent(in)   , target :: dynamics
    type(t_tracer), intent(inout), target :: tracers
    type(t_partit), intent(inout), target :: partit
    type(t_mesh)  , intent(in)   , target :: mesh
    !___________________________________________________________________________
    integer                    :: n, elem, elnodes(3),n1
    real(kind=WP)              :: rsss, net
    real(kind=WP), allocatable :: flux(:)
    !___________________________________________________________________________
    real(kind=WP), dimension(:,:), pointer :: temp, salt
    real(kind=WP), dimension(:)  , pointer :: a_ice, m_ice, m_snow
    real(kind=WP), dimension(:)  , pointer :: a_ice_old
    real(kind=WP), dimension(:)  , pointer :: thdgr, thdgrsn
    real(kind=WP), dimension(:)  , pointer :: fresh_wa_flux, net_heat_flux
    real(kind=WP)                , pointer :: rhoice, rhosno, inv_rhowat
#include "associate_part_def.h"
#include "associate_mesh_def.h"
#include "associate_part_ass.h"
#include "associate_mesh_ass.h"
    temp          => tracers%data(1)%values(:,:)
    salt          => tracers%data(2)%values(:,:)
    a_ice         => ice%data(1)%values(:)
    m_ice         => ice%data(2)%values(:)
    m_snow        => ice%data(3)%values(:)
    a_ice_old     => ice%data(1)%values_old(:)
    thdgr         => ice%thermo%thdgr(:)
    thdgrsn       => ice%thermo%thdgrsn(:)
    fresh_wa_flux => ice%flx_fw(:)
    net_heat_flux => ice%flx_h(:)
    rhoice        => ice%thermo%rhoice
    rhosno        => ice%thermo%rhosno
    inv_rhowat    => ice%thermo%inv_rhowat
    
    !___________________________________________________________________________
    allocate(flux(myDim_nod2D+eDim_nod2D))

!$OMP PARALLEL DO
    do n=1, myDim_nod2d+eDim_nod2d  
       flux(n) = 0.0_WP
    end do
!$OMP END PARALLEL DO

    ! ==================
    ! heat and freshwater
    ! ==================   
    !___________________________________________________________________________
    ! from here on: 
    !    (-)  (+)
    !     |    ^
    ! ~~~~|~~~~|~~~~
    !     V    |
    !     
#if defined (__icepack)

    call icepack_to_fesom (nx_in=(myDim_nod2D+eDim_nod2D), &
                           aice_out=a_ice,                 &
                           vice_out=m_ice,                 &
                           vsno_out=m_snow,                &
                           fhocn_tot_out=net_heat_flux,    &
                           fresh_tot_out=fresh_wa_flux,    &
                           fsalt_out=real_salt_flux,       &
                           dhi_dt_out=thdgrsn,             &
                           dhs_dt_out=thdgr,               &
                           evap_ocn_out=evaporation        )

    heat_flux(:)   = - net_heat_flux(:)
    water_flux(:)  = - (fresh_wa_flux(:)/1000.0_WP) - runoff(:)

    ! Evaporation
    evaporation(:) = - evaporation(:) / 1000.0_WP
    ice_sublimation(:) = 0.0_WP

    call init_flux_atm_ocn()

#else
!$OMP PARALLEL DO
    do n=1, myDim_nod2d+eDim_nod2d  
       heat_flux(n)   = -net_heat_flux(n)
       water_flux(n)  = -fresh_wa_flux(n)
    end do
!$OMP END PARALLEL DO
#endif

!$OMP PARALLEL DO
    do n=1, myDim_nod2d+eDim_nod2d  
       heat_flux_in(n)=heat_flux(n) ! sw_pene will change the heat_flux
    end do
!$OMP END PARALLEL DO
    if (use_cavity) call cavity_heat_water_fluxes_3eq(ice, dynamics, tracers, partit, mesh)   
    !___________________________________________________________________________
    call exchange_nod(heat_flux, water_flux, partit)
!$OMP BARRIER
    !___________________________________________________________________________
    ! on freshwater inflow/outflow or virtual salinity:
    ! 1. In zlevel & zstar the freshwater flux is applied in the update of the 
    ! ssh matrix when solving the continuity equation of vertically 
    ! integrated flow. The salt concentration in the first layer will 
    ! be then adjusted according to the change in volume.
    ! In this case rsss is forced to be zero by setting ref_sss=0. and ref_sss_local=.false.
    ! in routines above.
    ! 2. In cases where the volume of the upper layer is fixed (i.e. linfs)  the freshwater flux 
    ! 'rsss*water_flux(n)' is applied as a virtual salt boundary condition via the vertical 
    ! diffusion operator.
    ! --> rsss*water_flux(n) : virtual salt flux 
    !___________________________________________________________________________
    ! balance virtual salt flux
    if (use_virt_salt) then ! will remain zero otherwise
        rsss=ref_sss
!$OMP PARALLEL DO
        do n=1, myDim_nod2D+eDim_nod2D
            if (ref_sss_local) rsss = salt(ulevels_nod2d(n),n)
            virtual_salt(n)=rsss*water_flux(n) 
        end do
!$OMP END PARALLEL DO        
        if (use_cavity) then
            flux = virtual_salt
            where (ulevels_nod2d > 1) flux = 0.0_WP
            call integrate_nod(flux, net, partit, mesh)
        else   
            call integrate_nod(virtual_salt, net, partit, mesh)
        end if
!$OMP PARALLEL DO 
        do n=1, myDim_nod2D+eDim_nod2D
           virtual_salt(n)=virtual_salt(n)-net/ocean_area
        end do
!$OMP END PARALLEL DO
    end if

!$OMP PARALLEL DO
    do n=1, myDim_nod2D+eDim_nod2D    
      if (ulevels_nod2d(n) == 1) then
             dens_flux(n)=sw_alpha(1,n) * heat_flux_in(n) / vcpw + sw_beta(1, n) * (relax_salt(n) + water_flux(n) * salt(1,n))
      else
             dens_flux(n)=0.0_WP
      end if
    end do
!$OMP END PARALLEL DO
    !___________________________________________________________________________
    ! balance SSS restoring to climatology
    if (use_cavity) then
        do n=1, myDim_nod2D+eDim_nod2D
            relax_salt(n) = 0.0_WP
            if (ulevels_nod2d(n) > 1) cycle
            relax_salt(n)=surf_relax_S*(Ssurf(n)-salt(ulevels_nod2d(n),n))
        end do
    else
!$OMP PARALLEL DO
        do n=1, myDim_nod2D+eDim_nod2D
            relax_salt(n)=surf_relax_S*(Ssurf(n)-salt(ulevels_nod2d(n),n))
        end do
!$OMP END PARALLEL DO
    end if 
    
    ! --> if use_cavity=.true. relax_salt anyway zero where is cavity see above
    call integrate_nod(relax_salt, net, partit, mesh)
!$OMP PARALLEL DO
        do n=1, myDim_nod2D+eDim_nod2D
           relax_salt(n)=relax_salt(n)-net/ocean_area
        end do
!$OMP END PARALLEL DO
    
    !___________________________________________________________________________
    ! enforce the total freshwater/salt flux be zero
    ! 1. water flux ! if (.not. use_virt_salt) can be used!
    ! we conserve only the fluxes from the database plus evaporation.
!$OMP PARALLEL DO
        do n=1, myDim_nod2D+eDim_nod2D
           flux(n) = evaporation(n)-ice_sublimation(n)  & ! the ice2atmos subplimation does not contribute to the freshwater flux into the ocean
            +prec_rain(n)                               &
            +prec_snow(n)*(1.0_WP-a_ice_old(n))         &
            +runoff(n)
        end do
!$OMP END PARALLEL DO
    ! --> In case of zlevel and zstar and levitating sea ice, sea ice is just sitting 
    ! on top of the ocean without displacement of water, there the thermodynamic 
    ! growth rates of sea ice have to be taken into account to preserve the fresh water 
    ! flux. In the case of floating sea ice, water is displaced by 
    ! sea ice and flux conservation from ocean sea ice transformation follows from 
    ! the conservation of volume
    ! --> In case of linfs ocean sea ice transformation is balanced by the virtual 
    ! salinity flux
    !!PS   if ( .not. use_floatice .and. .not. use_virt_salt) then
    if (.not. use_virt_salt) then
!$OMP PARALLEL DO
        do n=1, myDim_nod2D+eDim_nod2D
           flux(n) = flux(n)-thdgr(n)*rhoice*inv_rhowat-thdgrsn(n)*rhosno*inv_rhowat
        end do
!$OMP END PARALLEL DO
    end if     
    
    ! Also balance freshwater flux that come from ocean-cavity boundary
    if (use_cavity) then
        if (.not. use_virt_salt) then !zstar, zlevel
            ! only for full-free surface approach otherwise total ocean volume will drift
            where (ulevels_nod2d > 1) flux = -water_flux
        else ! linfs 
            where (ulevels_nod2d > 1) flux =  0.0_WP
        end if 
    end if 
    
    ! compute total global net freshwater flux into the ocean 
    call integrate_nod(flux, net, partit, mesh)
    
    !___________________________________________________________________________
    ! here the + sign must be used because we switched up the sign of the 
    ! water_flux with water_flux = -fresh_wa_flux, but evap, prec_... and runoff still
    ! have there original sign
    ! if use_cavity=.false. --> ocean_area == ocean_areawithcav
    !! water_flux=water_flux+net/ocean_area
    if (use_cavity) then
        ! due to rigid lid approximation under the cavity we to not add freshwater
        ! under the cavity for the freshwater balancing we do this only for the open
        ! ocean
        where (ulevels_nod2d == 1) water_flux=water_flux+net/ocean_area
    else
!$OMP PARALLEL DO
        do n=1, myDim_nod2D+eDim_nod2D
           water_flux(n)=water_flux(n)+net/ocean_area
        end do
!$OMP END PARALLEL DO
    end if 
    
    !___________________________________________________________________________
    if (use_sw_pene) call cal_shortwave_rad(ice, partit, mesh)
    
    !___________________________________________________________________________
    deallocate(flux)
    
end subroutine oce_fluxes
!
!
!_______________________________________________________________________________
