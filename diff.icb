diff --git a/src/fesom_module.F90 b/src/fesom_module.F90
index 90c6d78c..8333f50a 100755
--- a/src/fesom_module.F90
+++ b/src/fesom_module.F90
@@ -237,7 +237,7 @@ contains
         ! --------------
         ! LA icebergs: 2023-05-17 
         if (use_icebergs) then
-            call allocate_icb(f%partit)
+            call allocate_icb(f%partit, f%mesh)
         endif
         ! --------------
 
@@ -483,13 +483,13 @@ end if
             if (f%ice%ice_update) call ice_timestep(n, f%ice, f%partit, f%mesh)  
 
             
-            ! LA commented for debugging
-            ! --------------
-            ! LA icebergs: 2023-05-17 
-            if (use_icebergs .and. mod(n, steps_per_ib_step)==0.0) then
-                call icb2fesom(f%mesh, f%partit, f%ice)
-            end if
-            ! --------------
+            !! LA commented for debugging
+            !! --------------
+            !! LA icebergs: 2023-05-17 
+            !if (use_icebergs .and. mod(n, steps_per_ib_step)==0.0) then
+            !    call icb2fesom(f%mesh, f%partit, f%ice)
+            !end if
+            !! --------------
 
 
             !___compute fluxes to the ocean: heat, freshwater, momentum_________
diff --git a/src/gen_forcing_couple.F90 b/src/gen_forcing_couple.F90
index ba9247d2..fead4f55 100755
--- a/src/gen_forcing_couple.F90
+++ b/src/gen_forcing_couple.F90
@@ -574,6 +574,15 @@ subroutine update_atm_forcing(istep, ice, tracers, dynamics, partit, mesh)
 #endif /* skip all in case of __ifsinterface */
 #endif /* (__oasis) */
 
+  !! PSong: Antarctica runoff masked (lat<-60)
+  if (use_cavity) then
+     do i=1, myDim_nod2D+eDim_nod2D
+        if (geo_coord_nod2D(2,i) < -60.0*rad) then
+           runoff(i) = 0.0_WP
+        end if
+     end do
+  end if
+
   t2=MPI_Wtime()
 
 #ifdef VERBOSE
diff --git a/src/gen_modules_config.F90 b/src/gen_modules_config.F90
index a23f0c1c..cce25132 100755
--- a/src/gen_modules_config.F90
+++ b/src/gen_modules_config.F90
@@ -121,6 +121,9 @@ module g_config
   logical                       :: turn_off_hf=.false.
   logical                       :: turn_off_fw=.false.
   logical                       :: use_icesheet_coupling=.false.  
+  logical                       :: lbalance_fw=.true.  
+  logical                       :: lcell_saturation=.true.  
+  logical                       :: lmin_latent_hf=.true.  
   integer                       :: ib_num=0
   integer                       :: steps_per_ib_step=8
 
@@ -131,7 +134,7 @@ module g_config
   integer                       :: ib_async_mode=0
   integer                       :: thread_support_level_required=3 ! 2 = MPI_THREAD_SERIALIZED, 3 = MPI_THREAD_MULTIPLE
 
-  namelist /icebergs/ use_icebergs, turn_off_hf, turn_off_fw, use_icesheet_coupling, ib_num, steps_per_ib_step, ib_async_mode, thread_support_level_required
+  namelist /icebergs/ use_icebergs, turn_off_hf, turn_off_fw, use_icesheet_coupling, lbalance_fw, lcell_saturation, lmin_latent_hf, ib_num, steps_per_ib_step, ib_async_mode, thread_support_level_required
 
 !wiso-code!!!
   logical                       :: lwiso  =.false.  ! enable isotope?
diff --git a/src/icb_allocate.F90 b/src/icb_allocate.F90
index 169f7312..73bff016 100644
--- a/src/icb_allocate.F90
+++ b/src/icb_allocate.F90
@@ -1,21 +1,33 @@
-subroutine allocate_icb(partit)
+subroutine allocate_icb(partit, mesh)
   use iceberg_params
   use g_config
+  use g_comm
+  use g_comm_auto
+  use o_param
   use MOD_PARTIT
+  use MOD_MESH
 
   integer       :: n2
 type(t_partit), intent(inout), target :: partit
+type(t_mesh), intent(in), target :: mesh
 #include "associate_part_def.h"
+#include "associate_mesh_def.h"
 #include "associate_part_ass.h"
+#include "associate_mesh_ass.h"
   n2=myDim_nod2D+eDim_nod2D
+  icb_outfreq = step_per_day / steps_per_ib_step
 
   allocate(ibhf(n2), ibfwb(n2), ibfwl(n2), ibfwe(n2), ibfwbv(n2))
-  ibhf=0
-  ibfwb=0
-  ibfwl=0
-  ibfwe=0
-  ibfwbv=0
+  ibhf      = 0.0
+  ibfwb     = 0.0
+  ibfwl     = 0.0
+  ibfwe     = 0.0
+  ibfwbv    = 0.0
+  allocate(ibhf_n(mesh%nl, n2))
+  ibhf_n    = 0.0_WP
 
+  allocate(T_ave(ib_num))
+  T_ave = 0.0
   allocate(calving_day(ib_num))
   calving_day = 1   !28.0: September 29 for restart in 1 SEP 97 ! 271.0: September 29 for year 1997
   allocate(height_ib(ib_num))
@@ -83,16 +95,29 @@ type(t_partit), intent(inout), target :: partit
   allocate(fwl_flux_ib(ib_num))
   allocate(fwb_flux_ib(ib_num))
   allocate(fwbv_flux_ib(ib_num))
-  allocate(heat_flux_ib(ib_num))
-  allocate(lheat_flux_ib(ib_num))
+  allocate(hfe_flux_ib(ib_num))
+  allocate(hfl_flux_ib(ib_num))
+  allocate(hfb_flux_ib(ib_num))
+  allocate(hfbv_flux_ib(ib_num))
+  allocate(lhfb_flux_ib(ib_num))
   fwe_flux_ib = 0.0
   fwl_flux_ib = 0.0
   fwb_flux_ib = 0.0
   fwbv_flux_ib = 0.0
-  heat_flux_ib = 0.0
-  lheat_flux_ib = 0.0
+  hfe_flux_ib = 0.0
+  hfl_flux_ib = 0.0
+  hfb_flux_ib = 0.0
+  hfbv_flux_ib = 0.0
+  lhfb_flux_ib = 0.0
   allocate(arr_block(15*ib_num))
   allocate(elem_block(ib_num))
+  allocate(pe_block(ib_num))
+  
+  allocate(elem_area_glob(elem2D))
+  elem_area_glob=0.0
+  call gather_elem(elem_area(1:myDim_elem2D), elem_area_glob, partit)
+  call MPI_Bcast(elem_area_glob, elem2D, MPI_DOUBLE, 0, MPI_COMM_FESOM, MPIERR)
+
   allocate(vl_block(4*ib_num))
   allocate(buoy_props(ib_num,13))
   buoy_props = 0.0
diff --git a/src/icb_coupling.F90 b/src/icb_coupling.F90
index a715f392..a9ed4573 100644
--- a/src/icb_coupling.F90
+++ b/src/icb_coupling.F90
@@ -5,15 +5,16 @@ subroutine reset_ib_fluxes()
     use g_config
     use iceberg_params
 
-    ibfwbv = 0
-    ibfwb = 0
-    ibfwl = 0
-    ibfwe = 0
-    ibhf = 0
+    ibfwbv  = 0.0
+    ibfwb   = 0.0
+    ibfwl   = 0.0
+    ibfwe   = 0.0
+    ibhf    = 0.0
+    ibhf_n  = 0.0_WP
 end subroutine
 
 
-subroutine prepare_icb2fesom(mesh, partit, ib,i_have_element,localelement,depth_ib)
+subroutine prepare_icb2fesom(mesh, partit, ib,i_have_element,localelement,depth_ib,height_ib_single)
     !transmits the relevant fields from the iceberg to the ocean model
     !Lars Ackermann, 17.03.2020
 
@@ -23,14 +24,19 @@ subroutine prepare_icb2fesom(mesh, partit, ib,i_have_element,localelement,depth_
     use MOD_PARTIT
     use iceberg_params
 
+    implicit none
+
     logical                 :: i_have_element
-    real                    :: depth_ib
+    real, intent(in)        :: depth_ib, height_ib_single
+    real                    :: lev_low, lev_up
     integer                 :: localelement
     integer                 :: iceberg_node  
     integer, dimension(3)   :: ib_nods_in_ib_elem
     integer                 :: num_ib_nods_in_ib_elem
-    real                    :: tot_area_nods_in_ib_elem
-    integer                 :: i, ib
+    real                    :: dz
+    real, dimension(:), allocatable      :: tot_area_nods_in_ib_elem
+    integer                 :: i, j, k, ib
+    integer, dimension(3)   :: idx_d
 type(t_mesh), intent(in) , target :: mesh
 type(t_partit), intent(inout), target :: partit
 #include "associate_part_def.h"
@@ -39,30 +45,87 @@ type(t_partit), intent(inout), target :: partit
 #include "associate_mesh_ass.h"
 
     if(i_have_element) then 
+        dz = 0.0
+        allocate(tot_area_nods_in_ib_elem(mesh%nl))
+
         num_ib_nods_in_ib_elem=0
-        tot_area_nods_in_ib_elem=0
+        tot_area_nods_in_ib_elem=0.0
+        idx_d = 0
 
         do i=1,3
             iceberg_node=elem2d_nodes(i,localelement)
 
+            ! LOOP: consider all neighboring pairs (n_up,n_low) of 3D nodes
+            ! below n2..
+            !innerloop: do k=1, nl+1
+            do k=1, nlevels_nod2D(iceberg_node)
+                idx_d(i) = k
+                lev_up  = mesh%zbar_3d_n(k, iceberg_node)
+
+                if( k==nlevels_nod2D(iceberg_node) ) then
+                    lev_low = mesh%zbar_n_bot(iceberg_node)
+                else
+                    lev_low = mesh%zbar_3d_n(k+1, iceberg_node)
+                end if
+                
+                if( abs(lev_low)==abs(lev_up) ) then
+                    idx_d(i) = idx_d(i) - 1
+                    exit
+                else if( abs(lev_low)>=abs(depth_ib) ) then
+                    exit
+                else
+                    cycle
+                end if
+            end do
+                
             if (iceberg_node<=mydim_nod2d) then
-                ib_nods_in_ib_elem(i)   = iceberg_node
-                num_ib_nods_in_ib_elem  = num_ib_nods_in_ib_elem + 1
-                tot_area_nods_in_ib_elem= tot_area_nods_in_ib_elem + mesh%area(1,iceberg_node)
+                ib_nods_in_ib_elem(i)           = iceberg_node
+                num_ib_nods_in_ib_elem          = num_ib_nods_in_ib_elem + 1
+                tot_area_nods_in_ib_elem        = tot_area_nods_in_ib_elem + mesh%area(:,iceberg_node)
             else
-                ib_nods_in_ib_elem(i)   = 0
+                ib_nods_in_ib_elem(i)           = 0
             end if
         end do
-        
+       
         do i=1, 3
             iceberg_node=ib_nods_in_ib_elem(i)
 
             if (iceberg_node>0) then
-                ibfwbv(iceberg_node) = ibfwbv(iceberg_node) - fwbv_flux_ib(ib) / tot_area_nods_in_ib_elem
-                ibfwb(iceberg_node) = ibfwb(iceberg_node) - fwb_flux_ib(ib) / tot_area_nods_in_ib_elem
-                ibfwl(iceberg_node) = ibfwl(iceberg_node) - fwl_flux_ib(ib) / tot_area_nods_in_ib_elem
-                ibfwe(iceberg_node) = ibfwe(iceberg_node) - fwe_flux_ib(ib) / tot_area_nods_in_ib_elem
-                ibhf(iceberg_node) = ibhf(iceberg_node) - heat_flux_ib(ib) / tot_area_nods_in_ib_elem
+                ibfwbv(iceberg_node) = ibfwbv(iceberg_node) - fwbv_flux_ib(ib) / tot_area_nods_in_ib_elem(1)
+                ibfwb(iceberg_node) = ibfwb(iceberg_node) - fwb_flux_ib(ib) / tot_area_nods_in_ib_elem(1)
+                ibfwl(iceberg_node) = ibfwl(iceberg_node) - fwl_flux_ib(ib) / tot_area_nods_in_ib_elem(1)
+                ibfwe(iceberg_node) = ibfwe(iceberg_node) - fwe_flux_ib(ib) / tot_area_nods_in_ib_elem(1)
+                !ibhf(iceberg_node) = ibhf(iceberg_node) - hfb_flux_ib(ib) / tot_area_nods_in_ib_elem(1)
+                
+                do j=1,idx_d(i)
+                    lev_up  = mesh%zbar_3d_n(j, iceberg_node)
+                    if( j==nlevels_nod2D(iceberg_node) ) then
+                        lev_low = mesh%zbar_n_bot(iceberg_node)
+                    else
+                        lev_low = mesh%zbar_3d_n(j+1, iceberg_node)
+                    end if
+                    dz = abs( lev_low - lev_up )
+                    if( (abs(lev_low)>=abs(depth_ib)) .and. (abs(lev_up)<abs(depth_ib)) ) then 
+                        dz = abs( lev_up - abs(depth_ib) )
+                    end if              
+                   
+!                    write(*,*) "LA DEBUG: hfbv_flux_ib(ib)=",hfbv_flux_ib(ib),", hfb_flux_ib(ib)=",hfb_flux_ib(ib),", hfl_flux_ib(ib)=",hfl_flux_ib(ib),", hfe_flux_ib(ib)=",hfe_flux_ib(ib)
+                    if( depth_ib==0.0 ) then
+                        ibhf_n(j,iceberg_node) = ibhf_n(j,iceberg_node) & 
+                                                    - ((hfbv_flux_ib(ib)+hfl_flux_ib(ib)) &
+                                                    + hfe_flux_ib(ib)) / tot_area_nods_in_ib_elem(j)
+                    else
+                        ibhf_n(j,iceberg_node) = ibhf_n(j,iceberg_node) & 
+                                                    - ((hfbv_flux_ib(ib)+hfl_flux_ib(ib)) * (dz / abs(depth_ib)) & 
+                                                    + hfe_flux_ib(ib) * (dz / abs(height_ib_single))) &
+                                                    / tot_area_nods_in_ib_elem(j)
+                    end if
+!                    write(*,*) "LA DEBUG: ibhf_n(j,iceberg_node)=",ibhf_n(j,iceberg_node),", height_ib_single=",height_ib_single
+                end do
+                ibhf_n(idx_d(i),iceberg_node) = ibhf_n(idx_d(i),iceberg_node) - hfb_flux_ib(ib) / tot_area_nods_in_ib_elem(idx_d(i))
+                if( height_ib_single .ne. 0.0 ) then
+                    ibhf_n(1,iceberg_node) = ibhf_n(1,iceberg_node) - hfe_flux_ib(ib) * ((abs(height_ib_single)-abs(depth_ib))/abs(height_ib_single)) / tot_area_nods_in_ib_elem(1)
+                end if
             end if
         end do
     end if
@@ -90,16 +153,13 @@ type(t_partit), intent(inout), target :: partit
 #include "associate_mesh_def.h"
 #include "associate_part_ass.h"
 #include "associate_mesh_ass.h"
-  
-    fresh_wa_flux => ice%flx_fw(:)
-    net_heat_flux => ice%flx_h(:)
 
     do n=1, myDim_nod2d+eDim_nod2D
-        if (.not.turn_off_hf) then
-                net_heat_flux(n)   = net_heat_flux(n) + ibhf(n) 
-        end if
+        !if (.not.turn_off_hf) then
+        !        heat_flux(n)   = heat_flux(n) - ibhf(n) !* steps_per_ib_step
+        !end if
         if (.not.turn_off_fw) then
-                fresh_wa_flux(n)   = fresh_wa_flux(n) + (ibfwb(n)+ibfwl(n)+ibfwe(n)+ibfwbv(n))
+                water_flux(n)  = water_flux(n) - (ibfwb(n)+ibfwl(n)+ibfwe(n)+ibfwbv(n)) !* steps_per_ib_step
         end if
     end do
 !---wiso-code-begin
diff --git a/src/icb_dyn.F90 b/src/icb_dyn.F90
index 7a0fb436..e64a686e 100644
--- a/src/icb_dyn.F90
+++ b/src/icb_dyn.F90
@@ -35,7 +35,7 @@ subroutine iceberg_dyn(mesh, partit, ice, dynamics, ib, new_u_ib, new_v_ib, u_ib
  use g_forcing_arrays 	!for u_wind, v_wind or u_wind_ib, v_wind_ib respectively
  use o_arrays, only: Tsurf_ib, Ssurf_ib
  use o_param		!for dt
- !use iceberg_params,only: l_melt, coriolis_scale !are icebergs allowed to melt?
+ use iceberg_params, only: T_ave !l_melt, coriolis_scale !are icebergs allowed to melt?
 
  integer, intent(IN) 	:: ib !current iceberg's index
  real,    intent(OUT)	:: new_u_ib, new_v_ib
@@ -90,16 +90,20 @@ type(t_dyn)   , intent(inout), target :: dynamics
  ! - (uo_skin_ib, vo_skin_ib)	: velocity below the draft of the iceberg
  ! call iceberg_avvelo_ufkeel(uo_dz,vo_dz, uo_keel,vo_keel, depth_ib,iceberg_elem) 
  call iceberg_average_andkeel(mesh, partit, dynamics, uo_dz,vo_dz, uo_keel,vo_keel, T_dz,S_dz, T_keel,S_keel, depth_ib,iceberg_elem, ib)
+ write(*,*) "LA DEBUG: dyn 1"
  call FEM_3eval(mesh, partit, uo_ib,vo_ib,lon,lat,uo_dz,vo_dz,iceberg_elem)
+ write(*,*) "LA DEBUG: dyn 2"
  call FEM_3eval(mesh, partit, uo_skin_ib,vo_skin_ib,lon,lat,uo_keel,vo_keel,iceberg_elem)
  
 
  !TEMPERATURE AND SALINITY:
  ! - T_ave_ib, S_ave_ib		: Mean T & S (integrated) at location of iceberg
  ! - T_keel_ib, S_keel_ib	: T & S below the draft of the iceberg (depth_ib)
+ write(*,*) "LA DEBUG: dyn 3"
  call FEM_3eval(mesh, partit, T_ave_ib,S_ave_ib,lon,lat,T_dz,S_dz,iceberg_elem)
+ write(*,*) "LA DEBUG: dyn 4"
  call FEM_3eval(mesh, partit, T_keel_ib,S_keel_ib,lon,lat,T_keel,S_keel,iceberg_elem)
-
+ T_ave(ib) = T_ave_ib
 
  !ATMOSPHERIC VELOCITY ua_ib, va_ib
  call FEM_eval(mesh, partit, ua_ib,va_ib,lon,lat,u_wind_ib,v_wind_ib,iceberg_elem)      
@@ -110,6 +114,7 @@ type(t_dyn)   , intent(inout), target :: dynamics
  !ICE THICKNESS (CONCENTRATION) hi_ib, conci_ib
  hi_ib3    => ice%data(size(ice%data))%values(:) !ice%m_ice_ib(tmp_arr)
  conci_ib3 => ice%data(size(ice%data)-1)%values(:) !ice%a_ice_ib(tmp_arr) 
+ write(*,*) "LA DEBUG: dyn 5"
  call FEM_3eval(mesh, partit, hi_ib,conci_ib,lon,lat,hi_ib3,conci_ib3,iceberg_elem)
  P_ib = 20000. * hi_ib * exp(-20.*(1-conci_ib))
  
@@ -135,11 +140,12 @@ type(t_dyn)   , intent(inout), target :: dynamics
  if(l_melt) then
 
   call FEM_eval(mesh, partit, sst_ib,sss_ib,lon,lat,Tsurf_ib,Ssurf_ib,iceberg_elem)
-  call iceberg_meltrates(	M_b, M_v, M_e, M_bv, &
+  
+  call iceberg_meltrates(partit, M_b, M_v, M_e, M_bv, &
 				u_ib,v_ib, uo_ib,vo_ib, ua_ib,va_ib, &
 				sst_ib, length_ib, conci_ib, &
-				uo_skin_ib, vo_skin_ib, T_keel_ib, S_keel_ib, depth_ib, &
-				T_ave_ib, S_ave_ib, ib)
+				uo_skin_ib, vo_skin_ib, T_keel_ib, S_keel_ib, depth_ib, height_ib, &
+				T_ave_ib, S_ave_ib, ib, rho_icb)
 
   call iceberg_newdimensions(partit, ib, depth_ib,height_ib,length_ib,width_ib,M_b,M_v,M_e,M_bv, &
 			     rho_h2o, rho_icb, file3)
@@ -644,19 +650,26 @@ type(t_partit), intent(inout), target :: partit
    ! below n2..
    !innerloop: do k=1, nl+1
    innerloop: do k=1, nlevels_nod2D(n2)
-
-    if( k==1 ) then
-        lev_up = 0.0
-    else
-        lev_up  = mesh%Z_3d_n_ib(k-1, n2)
-        !lev_up  = mesh%Z_3d_n_ib(k-1, n2)
-    end if
+    lev_up  = mesh%zbar_3d_n(k, n2)
 
     if( k==nlevels_nod2D(n2) ) then
         lev_low = mesh%zbar_n_bot(n2)
     else
-        lev_low = mesh%Z_3d_n_ib(k, n2)
+        lev_low = mesh%zbar_3d_n(k+1, n2)
     end if
+
+    !if( k==1 ) then
+    !    lev_up = 0.0
+    !else
+    !    lev_up  = mesh%Z_3d_n_ib(k-1, n2)
+    !    !lev_up  = mesh%Z_3d_n_ib(k-1, n2)
+    !end if
+
+    !if( k==nlevels_nod2D(n2) ) then
+    !    lev_low = mesh%zbar_n_bot(n2)
+    !else
+    !    lev_low = mesh%Z_3d_n_ib(k, n2)
+    !end if
     dz = abs( lev_low - lev_up )
     
     !if( abs(lev_up)>=abs(depth_ib) ) then
@@ -694,7 +707,7 @@ type(t_partit), intent(inout), target :: partit
     if( abs(lev_low)>=abs(depth_ib) ) then !.AND. (abs(lev_up)<=abs(depth_ib)) ) then
 #endif
       if( abs(lev_up)<abs(depth_ib) ) then
-        dz = abs ( lev_up - depth_ib )
+        dz = abs(lev_up - depth_ib)
       else
         ! LA: Never go here, when starting with k=1
         dz = abs(depth_ib)
diff --git a/src/icb_elem.F90 b/src/icb_elem.F90
index c989f24d..7729b757 100644
--- a/src/icb_elem.F90
+++ b/src/icb_elem.F90
@@ -63,6 +63,7 @@ eta_n_ib => dynamics%eta_n_ib(:)
   nablaeta(1) = sum( eta_n_ib(elem2D_nodes(:,elem)) * gradient_sca(1:3, elem)) 
   nablaeta(2) = sum( eta_n_ib(elem2D_nodes(:,elem)) * gradient_sca(4:6, elem)) 
  else
+ write(*,*) "LA DEBUG: elem 1"
   call FEM_3eval(mesh, partit, nablaeta(1),nablaeta(2),lon_rad,lat_rad,gradientx,gradienty,elem)
  end if
   
@@ -175,6 +176,7 @@ type(t_partit), intent(inout), target :: partit
   
   !values of the 3 local basisfunctions at the 
   !position 'coords'
+!  write(*,*) "LA DEBUG: 1 - elem=",elem,", coords_tmp=",coords_tmp,", phi=",phi
   call locbafu_2D(mesh, partit, phi,elem,coords_tmp)
 
   values_u = field_u(elem2D_nodes(:,elem))
@@ -353,6 +355,7 @@ type(t_partit), intent(inout), target :: partit
   !values of the 3 local basisfunctions at the 
   !position 'coords'
   coords_tmp = [lon_deg, lat_deg]
+!  write(*,*) "LA DEBUG: 2 - elem=",elem,", coords_tmp=",coords_tmp,", phi=",phi
   call locbafu_2D(mesh, partit, phi,elem, coords_tmp)
   
   u_at_ib = sum( ocean_u(:) * phi(:))
@@ -376,9 +379,6 @@ end subroutine FEM_3eval
 subroutine iceberg_elem4all(mesh, partit, elem, lon_deg, lat_deg) 
  USE MOD_MESH
  use MOD_PARTIT		!for myDim_nod2D, myList_elem2D
-!#ifdef use_cavity
-! use iceberg_params, only: reject_elem
-!#endif
  
  implicit none
  
@@ -392,36 +392,28 @@ type(t_partit), intent(inout), target :: partit
 #include "associate_mesh_def.h"
 #include "associate_part_ass.h"
 #include "associate_mesh_ass.h"
- 
+
+  write(*,*) "LA DEBUG: point_in_triangle 2 - lon/lat", lon_deg, "/", lat_deg
   call point_in_triangle(mesh, partit, elem, (/lon_deg, lat_deg/)) !all PEs search here
   i_have_element= (elem .ne. 0) !up to 3 PEs .true.
   
   if(i_have_element) then
    i_have_element= elem2D_nodes(1,elem) <= myDim_nod2D !1 PE still .true.
-#ifdef use_cavity
-   if( reject_elem(mesh, elem) ) then
+   if( (use_cavity) .and. (reject_elem(mesh, partit, elem) )) then
     elem=0 !reject element
     i_have_element=.false.
-    !write(*,*) 'elem4all: iceberg found in shelf region: elem = 0'
    else 
     elem=myList_elem2D(elem) !global now
    end if 
-#else
-   elem=myList_elem2D(elem) !global now
-#endif 
   end if
   call com_integer(partit, i_have_element,elem) !max 1 PE sends element here; 
 end subroutine iceberg_elem4all
 
 
  !***************************************************************************************************************************
- !***************************************************************************************************************************
 
 subroutine find_new_iceberg_elem(mesh, partit, old_iceberg_elem, pt, left_mype)
   use o_param
-!#ifdef use_cavity
-!  use iceberg_params, only: reject_elem
-!#endif
 
   implicit none
   
@@ -456,19 +448,17 @@ do m=1, 3
   !elem_containing_n2 = nod_in_elem2D(n2)%addresses(idx_elem_containing_n2)
   elem_containing_n2 = nod_in_elem2D(idx_elem_containing_n2,n2) 
     
+!  write(*,*) "LA DEBUG: 3 - elem=",elem_containing_n2,", coords_tmp=",pt,", phi=",werte2D
   call locbafu_2D(mesh, partit, werte2D, elem_containing_n2, pt)
    
   if (ALL(werte2D <= 1.+ 1.0e-07) .AND. ALL(werte2D >= 0.0- 1.0e-07) ) then
    old_iceberg_elem=elem_containing_n2
    
-#ifdef use_cavity
-   if( reject_elem(mesh, old_iceberg_elem) ) then
+   if( (use_cavity) .and. (reject_elem(mesh, partit, old_iceberg_elem) )) then
       left_mype=1.0
       !write(*,*) 'iceberg found in shelf region: left_mype = 1'
       old_iceberg_elem=ibelem_tmp
    end if
-#endif
-
    RETURN 
   end if
  end do
@@ -511,7 +501,7 @@ type(t_partit), intent(inout), target :: partit
   el2D=0
   !DO l=1,elem2D
   DO l=1,partit%myDim_elem2D
- 
+     !write(*,*) "LA DEBUG: 4 - coords_tmp=",pt,", phi=",werte2D, ", l=", l, ", nodes=",mesh%elem2D_nodes(:,l)
      call locbafu_2D(mesh, partit, werte2D, l, pt)
      
      if (ALL(werte2D <= 1.+ 1.0e-07) .AND. ALL(werte2D >= 0.0- 1.0e-07) ) then
diff --git a/src/icb_modules.F90 b/src/icb_modules.F90
index cda937e6..54b07794 100644
--- a/src/icb_modules.F90
+++ b/src/icb_modules.F90
@@ -1,4 +1,10 @@
 module iceberg_params
+use MOD_PARTIT
+USE MOD_MESH
+use g_config, only: use_cavity, use_cavityonelem
+use, intrinsic :: iso_fortran_env, only: real64
+USE o_PARAM, only: WP
+
 implicit none
 save
   !integer,parameter :: ib_num               ! realistic dataset comprising 6912 icebergs
@@ -74,7 +80,7 @@ save
   character(100):: scaling_file='icb_scaling.dat' !scaling factor
   
   !===== OUTPUT RELATED SETTINGS  =====
-  integer :: icb_outfreq = 180           ! 180; for FESOM_dt=2min this is 6 hourly output !120; for FESOM_dt=3min this is 6 hourly output
+  integer :: icb_outfreq           ! 180; for FESOM_dt=2min this is 6 hourly output !120; for FESOM_dt=3min this is 6 hourly output
   logical :: l_geo_out = .true.         ! output in unrotated (.true.) or rotated coordinates
   logical :: ascii_out = .false.        ! old ascii output (slow, more detailed); false: faster nc output
   !===== NUMERICS (DONT HAVE TO BE CHANGED) =====
@@ -82,16 +88,19 @@ save
   real :: semiimplicit_coeff = 1.0      !1. fully implicit, 0.5 no damping
   real :: AB_coeff = 1.53               !1.5 original AB (amplifying), 1.6 stabilized
   !===== NOTHING MUST BE CHANGED BELOW THIS LINE =====
+  real,dimension(:), allocatable:: T_ave
   real,dimension(:), allocatable:: u_ib, v_ib
   integer,dimension(:), allocatable:: iceberg_elem
   logical,dimension(:), allocatable:: find_iceberg_elem
   real,dimension(:), allocatable:: f_u_ib_old, f_v_ib_old
   real,dimension(:), allocatable:: bvl_mean, lvlv_mean, lvle_mean, lvlb_mean !averaged volume losses
-  !real,dimension(:), allocatable:: fw_flux_ib, heat_flux_ib
-  real,dimension(:), allocatable:: fwe_flux_ib, fwl_flux_ib, fwb_flux_ib, fwbv_flux_ib, heat_flux_ib, lheat_flux_ib
+  !real,dimension(:), allocatable:: fw_flux_ib, hfb_flux_ib
+  real,dimension(:), allocatable:: fwe_flux_ib, fwl_flux_ib, fwb_flux_ib, fwbv_flux_ib
+  real,dimension(:), allocatable:: hfe_flux_ib, hfl_flux_ib, hfb_flux_ib, hfbv_flux_ib, lhfb_flux_ib
   
   !===== FRESHWATER AND HEAT ARRAYS ON FESOM GRID =====
   real,dimension(:), allocatable:: ibhf    !icb heat flux into ocean 
+  real(kind=WP),dimension(:,:), allocatable:: ibhf_n    !icb heat flux into ocean 
   real,dimension(:), allocatable:: ibfwb   !freshwater flux into ocean from basal melting
   real,dimension(:), allocatable:: ibfwbv   !freshwater flux into ocean from basal melting
   real,dimension(:), allocatable:: ibfwl   !freshwater flux into ocean from lateral melting
@@ -104,6 +113,8 @@ save
   !for communication
   real,dimension(:), allocatable:: arr_block
   integer,dimension(:), allocatable:: elem_block
+  integer,dimension(:), allocatable:: pe_block
+  real(real64), dimension(:), allocatable:: elem_area_glob
   real,dimension(:), allocatable:: vl_block
 
   !array for output in netcdf
@@ -111,35 +122,50 @@ save
   integer:: save_count_buoys
   real:: prev_sec_in_year
 !****************************************************************************************************************************
-!****************************************************************************************************************************
-#ifdef use_cavity
  contains
  ! true if all nodes of the element are either "real" model boundary nodes or shelf nodes
- logical function reject_elem(mesh, elem)
- USE MOD_MESH
+ logical function reject_elem(mesh, partit, elem)
  implicit none
  integer, intent(in) :: elem
 type(t_mesh), intent(in) , target :: mesh
+type(t_partit), intent(inout), target :: partit
+#include "associate_part_def.h"
 #include "associate_mesh_def.h"
+#include "associate_part_ass.h"
 #include "associate_mesh_ass.h"
 
+if (use_cavity) then
 ! kh 09.08.21 change index_nod2d -> bc_index_nod2d?
- reject_elem = all( (cavity_flag_nod2d(elem2D_nodes(:,elem))==1) .OR. (index_nod2d(elem2D_nodes(:,elem))==1) )
+ if (.not. use_cavityonelem) then
+   reject_elem = all( (mesh%cavity_depth(mesh%elem2D_nodes(:,elem))/=0.0) .OR. (mesh%bc_index_nod2D(mesh%elem2D_nodes(:,elem))==0.0) )
+ !else
+ end if
+else
+ reject_elem = all( (mesh%bc_index_nod2D(mesh%elem2D_nodes(:,elem))==0.0) )
+endif
  end function reject_elem
  
  ! gives number of "coastal" nodes in cavity setup, i.e. number of nodes that are
  ! either "real" model boundary nodes or shelf nodes
- integer function coastal_nodes(mesh, elem)
- USE MOD_MESH
+ integer function coastal_nodes(mesh, partit, elem)
  implicit none
  integer, intent(in) :: elem
 type(t_mesh), intent(in) , target :: mesh
+type(t_partit), intent(inout), target :: partit
 #include "associate_part_def.h"
+#include "associate_mesh_def.h"
 #include "associate_part_ass.h"
+#include "associate_mesh_ass.h"
 
+if (use_cavity) then
 ! kh 09.08.21 change index_nod2d -> bc_index_nod2d?
- coastal_nodes = count( (cavity_flag_nod2d(elem2D_nodes(:,elem))==1) .OR. (index_nod2d(elem2D_nodes(:,elem))==1) )
+ if (.not. use_cavityonelem) then
+   coastal_nodes = count( (mesh%cavity_depth(mesh%elem2D_nodes(:,elem))/=0.0) .OR. (mesh%bc_index_nod2D(mesh%elem2D_nodes(:,elem))==0.0) )
+ !else
+ end if
+else 
+ coastal_nodes = count( (mesh%bc_index_nod2D(mesh%elem2D_nodes(:,elem))==0.0) )
+endif
  end function coastal_nodes
-#endif
 
 end module iceberg_params
diff --git a/src/icb_step.F90 b/src/icb_step.F90
index 03457192..8f9f88e2 100644
--- a/src/icb_step.F90
+++ b/src/icb_step.F90
@@ -11,7 +11,6 @@ implicit none
 
   public    ::  iceberg_calculation
   public    ::  iceberg_step1
-  public    ::  get_total_iceberg_area
   public    ::  iceberg_step2
   public    ::  initialize_velo
   public    ::  trajectory
@@ -53,12 +52,14 @@ subroutine iceberg_calculation(ice, mesh, partit, dynamics, istep)
  real(kind=8) 	:: t0, t1, t2, t3, t4, t0_restart, t1_restart   	!=
  logical	:: firstcall=.true. 					!=
  logical	:: lastsubstep  					!=
- 									!=
+       
  real		:: arr_from_block(15)					!=
  integer	:: elem_from_block					!=  
  real		:: vl_from_block(4)					!=	
  real,dimension(15*ib_num):: arr_block_red				!=
  integer,dimension(ib_num):: elem_block_red				!=
+ integer,dimension(ib_num):: pe_block_red				!=
+ integer    :: n
  real, dimension(4*ib_num):: vl_block_red				!=
 
 type(t_ice), intent(inout), target :: ice
@@ -73,7 +74,6 @@ type(t_dyn)   , intent(inout), target :: dynamics
 
 ! kh 16.03.21 (asynchronous) iceberg computation starts with the content in common arrays at istep and will merge its results at istep_end_synced
  istep_end_synced = istep + steps_per_ib_step - 1
-
  if(firstcall) then
   !overwrite icb_modules if restart, initialize netcdf output if no restart:
   
@@ -97,6 +97,7 @@ type(t_dyn)   , intent(inout), target :: dynamics
  !faster communication via ALLREDUCE
  arr_block = 0.0
  elem_block = 0
+ pe_block = 0
  !for communication of averaged volume losses
  vl_block = 0.0
 
@@ -138,6 +139,7 @@ type(t_dyn)   , intent(inout), target :: dynamics
  
  arr_block_red = 0.0
  elem_block_red= 0
+ pe_block_red= 0
  vl_block_red = 0.0
 
 !$omp critical 
@@ -162,6 +164,29 @@ completed = .false.
 !$omp end critical
  end do
 
+!$omp critical 
+ call MPI_IAllREDUCE(pe_block, pe_block_red, ib_num, MPI_INTEGER, MPI_SUM, partit%MPI_COMM_FESOM_IB, req, partit%MPIERR_IB)  
+!$omp end critical
+
+completed = .false.
+ do while (.not. completed)
+!$omp critical
+  CALL MPI_TEST(req, completed, status, partit%MPIERR_IB)
+!$omp end critical
+ end do
+
+!!$omp critical 
+! call MPI_IAllREDUCE(elem_area_block, elem_area_block_red, ib_num, MPI_REAL, MPI_SUM, partit%MPI_COMM_FESOM_IB, req, partit%MPIERR_IB)  
+!!$omp end critical
+!
+!completed = .false.
+! do while (.not. completed)
+!!$omp critical
+!  CALL MPI_TEST(req, completed, status, partit%MPIERR_IB)
+!!$omp end critical
+! end do
+
+
 !$omp critical 
  call MPI_IAllREDUCE(vl_block, vl_block_red, 4*ib_num, MPI_DOUBLE_PRECISION, MPI_SUM, partit%MPI_COMM_FESOM_IB, req, partit%MPIERR_IB)
 !$omp end critical
@@ -206,7 +231,8 @@ completed = .false.
                             conc_sill(ib),P_sill(ib), rho_h2o(ib),rho_air(ib),rho_ice(ib),	   	& 
                             u_ib(ib),v_ib(ib), iceberg_elem(ib), find_iceberg_elem(ib), lastsubstep,&
                             f_u_ib_old(ib), f_v_ib_old(ib), l_semiimplicit,   &
-                            semiimplicit_coeff, AB_coeff, istep)	
+                            semiimplicit_coeff, AB_coeff, istep, elem_block_red, &
+                            pe_block_red)	
     end if
   end if
 end do
@@ -243,6 +269,7 @@ end do
    write(*,*) 'reading restart took', t1_restart-t0_restart
    write(*,*) '*************************************************************'
  end if
+
 end subroutine iceberg_calculation
 
 
@@ -250,7 +277,7 @@ end subroutine iceberg_calculation
 !****************************************************************************************************************************
 
 
-subroutine iceberg_step1(ice, mesh, partit, dynamics, ib, height_ib,length_ib,width_ib, lon_deg,lat_deg, &
+subroutine iceberg_step1(ice, mesh, partit, dynamics, ib, height_ib_single,length_ib_single,width_ib_single, lon_deg,lat_deg, &
 			Co,Ca,Ci, Cdo_skin,Cda_skin, rho_icb, 		   &
 			conc_sill,P_sill, rho_h2o,rho_air,rho_ice,	   & 
 			u_ib,v_ib, iceberg_elem, find_iceberg_elem, 	   &
@@ -264,8 +291,7 @@ subroutine iceberg_step1(ice, mesh, partit, dynamics, ib, height_ib,length_ib,wi
  use g_rotate_grid	!for subroutine g2r, logfile_outfreq					!=
  use g_config, only: steps_per_ib_step
  !=
-!#ifdef use_cavity
-! use iceberg_params, only: smallestvol_icb, arr_block, elem_block, l_geo_out, icb_outfreq, l_allowgrounding, draft_scale, reject_elem, melted, grounded, scaling !, length_ib, width_ib, scaling
+use iceberg_params, only: length_ib, width_ib, scaling, elem_block, elem_area_glob !smallestvol_icb, arr_block, elem_block, l_geo_out, icb_outfreq, l_allowgrounding, draft_scale, reject_elem, melted, grounded, scaling !, length_ib, width_ib, scaling
 !#else
 ! use iceberg_params, only: smallestvol_icb, arr_block, elem_block, l_geo_out, icb_outfreq, l_allowgrounding, draft_scale, melted, grounded, scaling !, length_ib, width_ib, scaling
 !#endif
@@ -274,7 +300,7 @@ subroutine iceberg_step1(ice, mesh, partit, dynamics, ib, height_ib,length_ib,wi
  
  
  integer, intent(in)	:: ib, istep
- real,    intent(inout)	:: height_ib,length_ib,width_ib
+ real,    intent(inout)	:: height_ib_single,length_ib_single,width_ib_single
  real,    intent(inout)	:: lon_deg,lat_deg
  real, 	  intent(in)	:: Co,Ca,Ci, Cdo_skin,Cda_skin
  real,	  intent(in)	:: rho_icb, conc_sill,P_sill, rho_h2o,rho_air,rho_ice
@@ -334,17 +360,20 @@ type(t_dyn)   , intent(inout), target :: dynamics
 #include "associate_mesh_def.h"
 #include "associate_part_ass.h"
 #include "associate_mesh_ass.h"
- 
+
+
+!write(*,*) "LA DEBUG: 1"
  mype          =>partit%mype
 
  istep_end_synced = istep + steps_per_ib_step - 1
 
- depth_ib = -height_ib * rho_icb/rho_h2o
- volume_ib= length_ib * width_ib * height_ib  
+ depth_ib = -height_ib_single * rho_icb/rho_h2o
+ volume_ib= length_ib_single * width_ib_single * height_ib_single  
  mass_ib = volume_ib * rho_icb	 !less mass 
  lon_rad = lon_deg*rad
  lat_rad = lat_deg*rad
  
+!write(*,*) "LA DEBUG: 2"
  if(volume_ib .le. smallestvol_icb) then
   melted(ib) = .true.
 
@@ -354,6 +383,7 @@ type(t_dyn)   , intent(inout), target :: dynamics
 
   return
  end if 
+!write(*,*) "LA DEBUG: 3"
  
  if (firstcall) then
   if(mype==0) write(*,*) 'Preparing local_idx_of array...'
@@ -363,6 +393,7 @@ type(t_dyn)   , intent(inout), target :: dynamics
   firstcall=.false.
   if(mype==0) write(*,*) 'Preparing local_idx_of done.' 
  end if 
+!write(*,*) "LA DEBUG: 4"
  
  if (find_iceberg_elem) then
   lon_rad = lon_deg*rad
@@ -373,25 +404,27 @@ type(t_dyn)   , intent(inout), target :: dynamics
   
   !find LOCAL element where the iceberg starts:
   coords_tmp = [lon_deg, lat_deg]
+  write(*,*) "LA DEBUG: point_in_triangle 1 - lon/lat", lon_deg, "/", lat_deg
   call point_in_triangle(mesh, partit, iceberg_elem, coords_tmp)
   !call point_in_triangle(mesh, iceberg_elem, (/lon_deg, lat_deg/))
   i_have_element= (iceberg_elem .ne. 0) !up to 3 PEs possible
+!write(*,*) "LA DEBUG: 4a"
   
   if(i_have_element) then
+!write(*,*) "LA DEBUG: 4a1"
    i_have_element= mesh%elem2D_nodes(1,iceberg_elem) <= partit%myDim_nod2D !1 PE still .true.
-#ifdef use_cavity
-   if(reject_elem(mesh, partit, iceberg_elem)) then
+!write(*,*) "LA DEBUG: 4a2"
+   if( (use_cavity) .and. (reject_elem(mesh, partit, iceberg_elem))) then
     iceberg_elem=0 !reject element
     i_have_element=.false.
    else 
     iceberg_elem=partit%myList_elem2D(iceberg_elem) !global now
    end if
-#else
-   
-   iceberg_elem=partit%myList_elem2D(iceberg_elem) !global now
-#endif 
+!write(*,*) "LA DEBUG: 4a3"
   end if
+!write(*,*) "LA DEBUG: 4b"
   call com_integer(partit, i_have_element,iceberg_elem)
+!write(*,*) "LA DEBUG: 4c"
  
   if(iceberg_elem .EQ. 0) then
         write(*,*) 'IB ',ib,' rot. coords:', lon_deg, lat_deg !,lon_rad, lat_rad
@@ -400,7 +433,9 @@ type(t_dyn)   , intent(inout), target :: dynamics
   end if
   
   ! initialize the iceberg velocity
+!write(*,*) "LA DEBUG: 4d"
   call initialize_velo(mesh, partit, dynamics, i_have_element, ib, u_ib, v_ib, lon_rad, lat_rad, depth_ib, local_idx_of(iceberg_elem))
+!write(*,*) "LA DEBUG: 4e"
 
   !iceberg elem of ib is found
   find_iceberg_elem = .false.
@@ -417,8 +452,10 @@ type(t_dyn)   , intent(inout), target :: dynamics
       
     endif
   endif
+!write(*,*) "LA DEBUG: 4f"
  end if
  
+!write(*,*) "LA DEBUG: 5"
  
  ! ================== START ICEBERG CALCULATION ====================
  
@@ -428,7 +465,10 @@ type(t_dyn)   , intent(inout), target :: dynamics
  !if the first node belongs to this processor.. (just one processor enters here!)
  !if( local_idx_of(iceberg_elem) > 0 .and. elem2D_nodes(1,local_idx_of(iceberg_elem)) <= myDim_nod2D ) then
 if( local_idx_of(iceberg_elem) > 0 ) then 
+!write(*,*) "LA DEBUG: 5a"
+
   if( elem2D_nodes(1,local_idx_of(iceberg_elem)) <= partit%myDim_nod2D ) then
+!write(*,*) "LA DEBUG: 5b"
 
   i_have_element=.true. 
 
@@ -440,14 +480,13 @@ if( local_idx_of(iceberg_elem) > 0 ) then
   
 
   call iceberg_dyn(mesh, partit, ice, dynamics, ib, new_u_ib, new_v_ib, u_ib, v_ib, lon_rad,lat_rad, depth_ib, &
-                   height_ib, length_ib, width_ib, local_idx_of(iceberg_elem), &
+                   height_ib_single, length_ib_single, width_ib_single, local_idx_of(iceberg_elem), &
   		   mass_ib, Ci, Ca, Co, Cda_skin, Cdo_skin, &
   		   rho_ice, rho_air, rho_h2o, P_sill,conc_sill, frozen_in, &
   		   file_forces_u, file_forces_v, P_ib, conci_ib, &
 		   dt*REAL(steps_per_ib_step), l_output, f_u_ib_old, &
 		   f_v_ib_old, l_semiimplicit, semiimplicit_coeff, &
 		   AB_coeff, file_meltrates, rho_icb)
-  call prepare_icb2fesom(mesh,partit,ib,i_have_element,local_idx_of(iceberg_elem),depth_ib)
 
   dudt = (new_u_ib-u_ib)/REAL(steps_per_ib_step) / dt
   dvdt = (new_v_ib-v_ib)/REAL(steps_per_ib_step) / dt
@@ -456,11 +495,13 @@ if( local_idx_of(iceberg_elem) > 0 ) then
  
   call depth_bathy(mesh,partit, Zdepth3, local_idx_of(iceberg_elem))
   !interpolate depth to location of iceberg (2 times because FEM_3eval expects a 2 component vector...)
+ write(*,*) "LA DEBUG: step 1"
   call FEM_3eval(mesh,partit, Zdepth,Zdepth,lon_rad,lat_rad,Zdepth3,Zdepth3,local_idx_of(iceberg_elem))
   !write(*,*) 'nodal depth in iceberg ', ib,'s element:', Zdepth3
   !write(*,*) 'depth at iceberg ', ib, 's location:', Zdepth
   
   !=================CHECK IF ICEBERG IS GROUNDED...===================
+ old_element = iceberg_elem !save if iceberg left model domain
  if((draft_scale(ib)*abs(depth_ib) .gt. Zdepth) .and. l_allowgrounding ) then 
  !if((draft_scale(ib)*abs(depth_ib) .gt. minval(Zdepth3)) .and. l_allowgrounding ) then 
    !icebergs remains stationary (iceberg can melt above in iceberg_dyn!)
@@ -469,25 +510,20 @@ if( local_idx_of(iceberg_elem) > 0 ) then
     v_ib = 0.0
     old_lon = lon_rad
     old_lat = lat_rad
-
-    !!###########################################
-    !! LA: prevent too many icebergs in one element
-    old_element = iceberg_elem !save if iceberg left model domain
-    !!###########################################
  
 ! kh 16.03.21 (asynchronous) iceberg calculation starts with the content in common arrays at istep and will merge its results at istep_end_synced
-    if (mod(istep_end_synced,logfile_outfreq)==0) then 
-        write(*,*) 'iceberg ib ', ib, 'is grounded'
-        grounded(ib) = .true.
-    end if
+    grounded(ib) = .true.
+    !if (mod(istep_end_synced,logfile_outfreq)==0) then 
+! if(ib==148) write(*,*) "LA DEBUG: 3 - elem ", iceberg_elem
+    write(*,*) 'iceberg ib ', ib, 'is grounded'
+    !end if
  	
  else 
   !===================...ELSE CALCULATE TRAJECTORY====================
 
- ! LA: prevent too many icebergs in one element
- old_element = iceberg_elem !save if iceberg left model domain
  
  t0=MPI_Wtime()
+!write(*,*) "LA DEBUG: before_trajectory"
   call trajectory( lon_rad,lat_rad, u_ib,v_ib, new_u_ib,new_v_ib, &
 		   lon_deg,lat_deg,old_lon,old_lat, dt*REAL(steps_per_ib_step))
   	   
@@ -514,6 +550,7 @@ if( local_idx_of(iceberg_elem) > 0 ) then
    iceberg_elem=local_idx_of(iceberg_elem)  	!local
  t7=MPI_Wtime()
    call find_new_iceberg_elem(mesh,partit, iceberg_elem, (/lon_deg, lat_deg/), left_mype)
+
  t8=MPI_Wtime()
    iceberg_elem=partit%myList_elem2D(iceberg_elem)  	!global
   end if		   
@@ -522,35 +559,53 @@ if( local_idx_of(iceberg_elem) > 0 ) then
 
   !-----------------------------
   ! LA 2022-11-30
-  do idx = 1, size(elem_block)
-      if (elem_block(idx) == iceberg_elem) then
-          area_ib_tot = area_ib_tot + length_ib * width_ib * scaling(idx)
-      end if
-  end do
+!write(*,*) "LA DEBUG: before_saturation"
+  if(lcell_saturation) then
+!write(*,*) "LA DEBUG: start_saturation"
+    area_ib_tot = length_ib_single*width_ib_single*scaling(ib)
+!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(idx, area_ib_tot)
+!$OMP DO
+    do idx = 1, size(elem_block)
+        if (elem_block(idx) == iceberg_elem) then
+            area_ib_tot = area_ib_tot + length_ib(idx) * width_ib(idx) * scaling(idx)
+        end if
+    end do
+!write(*,*) "LA DEBUG: end_loop_saturation"
+!$OMP END DO
+!$OMP END PARALLEL
   !-----------------------------
 
-  if((area_ib_tot > elem_area(local_idx_of(iceberg_elem))) .and. &  
-                (iceberg_elem .ne. old_element) .and. &
-                (old_element .ne. 0) .and. &
-                (.not.grounded(ib))) then
-      lon_rad = old_lon
-      lat_rad = old_lat 
-      lon_deg = lon_rad/rad
-      lat_deg = lat_rad/rad
-      iceberg_elem = old_element
-      u_ib    = 0.
-      v_ib    = 0.  
+    if ((area_ib_tot > elem_area_glob(iceberg_elem)) .and. (old_element.ne.0) .and. (left_mype == 0)) then 
+        write(*,*) " *******************************************************"
+        write(*,*) " * set iceberg ", ib, " back to elem ", old_element, " from elem ", iceberg_elem
+        write(*,*) " * area_ib_tot = ", area_ib_tot, "; elem_area = ", elem_area(local_idx_of(iceberg_elem))
+        i_have_element = .true.
+        left_mype = 0.0
+        lon_rad = old_lon
+        lat_rad = old_lat 
+        lon_deg = lon_rad/rad
+        lat_deg = lat_rad/rad
+        iceberg_elem = old_element
+        u_ib    = 0.
+        v_ib    = 0.  
+    end if
+!write(*,*) "LA DEBUG: after_cell_saturation"
   end if
   !###########################################
  
   !values for communication
-  arr= (/ height_ib,length_ib,width_ib, u_ib,v_ib, lon_rad,lat_rad, &
+  arr= (/ height_ib_single,length_ib_single,width_ib_single, u_ib,v_ib, lon_rad,lat_rad, &
           left_mype, old_lon,old_lat, frozen_in, dudt, dvdt, P_ib, conci_ib/) 
 
   !save in larger array	  
   arr_block((ib-1)*15+1 : ib*15)=arr
   elem_block(ib)=iceberg_elem
-  	  
+  pe_block(ib)=mype
+
+  volume_ib=height_ib_single*length_ib_single*width_ib_single
+!write(*,*) "LA DEBUG: before_prepare"
+  call prepare_icb2fesom(mesh,partit,ib,i_have_element,local_idx_of(iceberg_elem),depth_ib,height_ib_single)
+!write(*,*) "LA DEBUG: after_prepare"
  end if !processor has element?
 end if !... and first node belongs to processor?
 
@@ -567,54 +622,25 @@ end if !... and first node belongs to processor?
  
  end subroutine iceberg_step1
 
-subroutine get_total_iceberg_area(mesh, partit,iceberg_elem, area_ib_tot)
- 
- use o_param 		!for rad								!=
- USE MOD_MESH
- use MOD_PARTIT		!for myDim_elem2D, myList_nod2D						!=
- use g_rotate_grid	!for subroutine g2r, logfile_outfreq					!=
- !use iceberg_params, only: arr_block, elem_block, length_ib, width_ib, scaling
- 
- implicit none											!=
- 
- integer, intent(inout) :: iceberg_elem !global
- real, intent(inout)    :: area_ib_tot
- integer                :: idx
 
-type(t_mesh), intent(in) , target :: mesh
-type(t_partit), intent(inout), target :: partit
-!========================= MODULES & DECLARATIONS =====================================!=
-#include "associate_part_def.h"
-#include "associate_mesh_def.h"
-#include "associate_part_ass.h"
-#include "associate_mesh_ass.h"
-
-  area_ib_tot = 0.0
-  do idx = 1, size(elem_block)
-      if (elem_block(idx) == iceberg_elem) then
-          area_ib_tot = area_ib_tot + length_ib(idx) * width_ib(idx) * scaling(idx)
-      end if
-  end do
-  !###########################################
-end subroutine get_total_iceberg_area
  
- 
-subroutine iceberg_step2(mesh, partit,arr, elem_from_block, ib, height_ib,length_ib,width_ib, lon_deg,lat_deg, &
+subroutine iceberg_step2(mesh, partit,arr, elem_from_block, ib, height_ib_single, length_ib_single, width_ib_single, lon_deg,lat_deg, &
 			Co,Ca,Ci, Cdo_skin,Cda_skin, rho_icb, 		   &
 			conc_sill,P_sill, rho_h2o,rho_air,rho_ice,	   & 
 			u_ib,v_ib, iceberg_elem, find_iceberg_elem, 	   &
 			lastsubstep, f_u_ib_old,	   &
 			f_v_ib_old, l_semiimplicit, semiimplicit_coeff,    &
-			AB_coeff, istep)
+			AB_coeff, istep, elem_block_red, pe_block_red)
 			
  !============================= MODULES & DECLARATIONS =========================================!=
  												!=
  use o_param 		!for rad								!=
  use g_rotate_grid	!for subroutine g2r, logfile_outfreq					!=
  use g_config, only: steps_per_ib_step
+ use g_comm_auto
 !=
-!#ifdef use_cavity
-! use iceberg_params, only: smallestvol_icb, buoy_props, bvl_mean, lvlv_mean, lvle_mean, lvlb_mean, ascii_out, l_geo_out, icb_outfreq, l_allowgrounding, draft_scale, reject_elem, elem_block
+use g_comm
+use iceberg_params, only: length_ib, width_ib, scaling !smallestvol_icb, arr_block, elem_block, l_geo_out, icb_outfreq, l_allowgrounding, draft_scale, reject_elem, melted, grounded, scaling !, length_ib, width_ib, scaling
 !#else
 ! use iceberg_params, only: smallestvol_icb, buoy_props, bvl_mean, lvlv_mean, lvle_mean, lvlb_mean, ascii_out, l_geo_out, icb_outfreq, l_allowgrounding, draft_scale, elem_block
 !#endif
@@ -624,7 +650,7 @@ subroutine iceberg_step2(mesh, partit,arr, elem_from_block, ib, height_ib,length
  real, 	  intent(in)	:: arr(15)
  integer, intent(in)	:: elem_from_block
  integer, intent(in)	:: ib
- real,    intent(inout)	:: height_ib,length_ib,width_ib
+ real,    intent(inout)	:: height_ib_single, length_ib_single, width_ib_single
  real,    intent(inout)	:: lon_deg,lat_deg
  real, 	  intent(in)	:: Co,Ca,Ci, Cdo_skin,Cda_skin
  real,	  intent(in)	:: rho_icb, conc_sill,P_sill, rho_h2o,rho_air,rho_ice
@@ -636,7 +662,8 @@ subroutine iceberg_step2(mesh, partit,arr, elem_from_block, ib, height_ib,length
  logical, intent(in)	:: l_semiimplicit
  real,    intent(in)	:: semiimplicit_coeff
  real,    intent(in)	:: AB_coeff						
- 
+ integer, intent(in), dimension(ib_num):: elem_block_red				!=
+ integer, intent(in), dimension(ib_num):: pe_block_red				!=
  
  integer, dimension(:), save, allocatable :: local_idx_of
  real      			:: depth_ib, volume_ib, mass_ib
@@ -653,9 +680,11 @@ subroutine iceberg_step2(mesh, partit,arr, elem_from_block, ib, height_ib,length
  integer :: istep_end_synced
  
 ! LA: add threshold for number of icebergs in one elemt
+ integer status(MPI_STATUS_SIZE)
  integer                        :: num_ib_in_elem, idx
  real                           :: area_ib_tot
- real                           :: local_elem_area
+ !real(real64), dimension(:), allocatable    :: rbuffer, local_elem_area
+ real(real64)                   :: elem_area_tmp 
 
  !iceberg output 
  character 			:: ib_char*10
@@ -701,9 +730,9 @@ type(t_partit), intent(inout), target :: partit
 
  iceberg_elem= elem_from_block !update element as before in com_values
  old_element = elem_from_block !save if iceberg left model domain
- height_ib= arr(1)
- length_ib= arr(2)
- width_ib = arr(3)
+ height_ib_single= arr(1)
+ length_ib_single= arr(2)
+ width_ib_single = arr(3)
  u_ib     = arr(4)
  v_ib     = arr(5)
  lon_rad  = arr(6)
@@ -718,9 +747,9 @@ type(t_partit), intent(inout), target :: partit
  dvdt	  = arr(13)
  P_ib	  = arr(14)
  conci_ib = arr(15) 
- 
+
  !**** check if iceberg melted in step 1 ****! 
- volume_ib = height_ib * length_ib * width_ib ! * rho_icb
+ volume_ib = height_ib_single * length_ib_single * width_ib_single ! * rho_icb
  if(volume_ib .le. smallestvol_icb) then
   buoy_props(ib, :) = 0. ! for output: NaN or MissVal could be written here
   return
@@ -738,10 +767,11 @@ type(t_partit), intent(inout), target :: partit
       call global2local(mesh, partit, local_idx_of, elem2D)
       firstcall=.false.
     end if 
- 
+
  if(left_mype > 0.) then
    call iceberg_elem4all(mesh, partit, iceberg_elem, lon_deg, lat_deg) !Just PE changed?
    if(iceberg_elem == 0 ) then
+           left_mype = 0.0
            lon_rad = old_lon
            lat_rad = old_lat 
            lon_deg = lon_rad/rad
@@ -749,18 +779,38 @@ type(t_partit), intent(inout), target :: partit
            iceberg_elem = old_element
            u_ib    = 0.
            v_ib    = 0.
-   else
+   else if(lcell_saturation) then
      if (mype==0) write(*,*) 'iceberg ',ib, ' changed PE or was very fast'
-     call get_total_iceberg_area(mesh, partit, iceberg_elem, area_ib_tot)
-     if(area_ib_tot > elem_area(local_idx_of(iceberg_elem))) then
+     elem_area_tmp = elem_area_glob(iceberg_elem)
+     area_ib_tot = length_ib_single * width_ib_single * scaling(ib)
+!$OMP PARALLEL DEFAULT(SHARED) PRIVATE(idx, area_ib_tot)
+!$OMP DO
+     do idx = 1, size(elem_block_red)
+         if (elem_block_red(idx) == iceberg_elem) then
+     !        write(*,*) " * Found element ",elem_block_red(idx), " for ib ",idx, ", elem_area=",elem_area_tmp
+             area_ib_tot = area_ib_tot + length_ib(idx) * width_ib(idx) * scaling(idx)
+         end if
+     end do
+!$OMP END DO
+!$OMP END PARALLEL
+     if((area_ib_tot > elem_area_tmp) .and. (elem_area_tmp > 0.0)) then
+         if(mype==pe_block_red(ib)) then
+            write(*,*) " *******************************************************"
+            write(*,*) " * iceberg changed PE and saturation"
+            write(*,*) " * set iceberg ", ib, " back to elem ", old_element, " from elem ", iceberg_elem
+            write(*,*) " * area_ib = ", length_ib_single * width_ib_single, "; area_ib_tot = ", area_ib_tot, "; elem_area = ", elem_area_tmp
+         end if
+         left_mype = 0.0
          lon_rad = old_lon
-         lat_rad = old_lat 
+         lat_rad = old_lat
          lon_deg = lon_rad/rad
          lat_deg = lat_rad/rad
          iceberg_elem = old_element
          u_ib    = 0.
-         v_ib    = 0.  
+         v_ib    = 0.
      end if
+   else if(lcell_saturation) then
+     if (mype==0) write(*,*) 'iceberg ',ib, ' changed PE or was very fast'
    end if
  end if
  
@@ -822,9 +872,9 @@ type(t_partit), intent(inout), target :: partit
   buoy_props(ib, 7) = dvdt_out
   buoy_props(ib, 8) = u_ib_out
   buoy_props(ib, 9) = v_ib_out
-  buoy_props(ib,10) = height_ib
-  buoy_props(ib,11) = length_ib 
-  buoy_props(ib,12) = width_ib
+  buoy_props(ib,10) = height_ib_single
+  buoy_props(ib,11) = length_ib_single 
+  buoy_props(ib,12) = width_ib_single
   buoy_props(ib,13) = iceberg_elem
 
 ! end if
@@ -832,14 +882,6 @@ type(t_partit), intent(inout), target :: partit
  end if 
  
  t4=MPI_Wtime()
- 
-! if (mod(istep,logfile_outfreq)==0 .and. mype==0 .and. lastsubstep) then 
-!  write(*,*) '*** step2 ***'
-!  write(*,*) 'comvalues took', t2-t1
-!  write(*,*) 'left mype took', t3-t2
-!  write(*,*) 'track out took', t4-t3
-! end if
-
 end subroutine iceberg_step2
 
 
@@ -887,6 +929,7 @@ type(t_partit), intent(inout), target :: partit
 	else
    		!OCEAN VELOCITY uo_ib, voib is start velocity
    		call iceberg_avvelo(mesh, partit, dynamics, startu,startv,depth_ib,localelem)
+ write(*,*) "LA DEBUG: step 2"
         call FEM_3eval(mesh, partit,u_ib,v_ib,lon_rad,lat_rad,startu,startv,localelem)
 	end if
  end if
@@ -983,15 +1026,14 @@ end subroutine depth_bathy
 !****************************************************************************************************************************
 
 subroutine parallel2coast(mesh, partit,u, v, lon,lat, elem)
-!#ifdef use_cavity
-! use iceberg_params, only: coastal_nodes
-!#endif
+ use iceberg_params, only: coastal_nodes
  implicit none
  
  real, intent(inout) 	:: u, v 	!velocity
  real, intent(in)	:: lon, lat 	!radiant
  integer, intent(in)	:: elem
  
+ integer :: fld_tmp
  integer, dimension(3) :: n
  integer :: node, m, i
  real, dimension(2) :: velocity, velocity1, velocity2
@@ -1004,12 +1046,13 @@ type(t_partit), intent(inout), target :: partit
 #include "associate_part_ass.h"
 #include "associate_mesh_ass.h"
 
-#ifdef use_cavity
-  SELECT CASE ( coastal_nodes(mesh, elem) ) !num of "coastal" points
-#else
-  SELECT CASE ( sum( mesh%bc_index_nod2D(mesh%elem2D_nodes(:,elem)) ) ) !num of coastal points
-  !SELECT CASE ( sum( bc_index_nod2D(elem2D_nodes(:,elem)) ) ) !num of coastal points
-#endif
+  if( use_cavity ) then
+    fld_tmp = coastal_nodes(mesh, partit, elem)
+  else
+    fld_tmp = sum( mesh%bc_index_nod2D(mesh%elem2D_nodes(:,elem)) )
+  end if
+  
+  SELECT CASE ( fld_tmp ) !num of coastal points
    CASE (0) !...coastal points: do nothing
     return
     
@@ -1020,14 +1063,18 @@ type(t_partit), intent(inout), target :: partit
     do m = 1, 3
       node = mesh%elem2D_nodes(m,elem)
       !write(*,*) 'index ', m, ':', index_nod2D(node)
-#ifdef use_cavity
-      if( mesh%bc_index_nod2D(node)==1 .OR. cavity_flag_nod2d(node)==1 ) then
-#else
-      if( mesh%bc_index_nod2D(node)==1 ) then
-#endif
-       n(i) = node
-       exit
-      end if 
+      if( use_cavity ) then
+        !if( mesh%bc_index_nod2D(node)==1 .OR. cavity_flag_nod2d(node)==1 ) then
+        if( mesh%bc_index_nod2D(node)==0.0 .OR.  (mesh%cavity_depth(node)/=0.0) ) then
+         n(i) = node
+         exit
+        end if 
+      else
+        if( mesh%bc_index_nod2D(node)==1 ) then
+         n(i) = node
+         exit
+        end if 
+      end if
     end do 
     
    !write(*,*) 'one coastal node ', n(1)
@@ -1075,13 +1122,17 @@ type(t_partit), intent(inout), target :: partit
     velocity = [ u, v ]
     do m = 1, 3
       node = mesh%elem2D_nodes(m,elem) 
-#ifdef use_cavity
-      if( (mesh%bc_index_nod2D(node)==1) .OR. (cavity_flag_nod2d(node)==1)) then
-#else
-      if( mesh%bc_index_nod2D(node)==1 ) then
-#endif
-       n(i) = node
-       i = i+1
+      if( use_cavity ) then
+        !if( (mesh%bc_index_nod2D(node)==1) .OR. (cavity_flag_nod2d(node)==1)) then
+        if( mesh%bc_index_nod2D(node)==0.0 .OR.  (mesh%cavity_depth(node)/=0.0) ) then
+         n(i) = node
+         i = i+1
+        end if
+      else
+        if( mesh%bc_index_nod2D(node)==1 ) then
+         n(i) = node
+         i = i+1
+        end if
       end if
     end do   
     call projection(mesh,partit,  velocity, n(1), n(2))
diff --git a/src/icb_thermo.F90 b/src/icb_thermo.F90
index 73ea38c5..090cf075 100644
--- a/src/icb_thermo.F90
+++ b/src/icb_thermo.F90
@@ -1,4 +1,4 @@
-!==============================================================================
+!!=============================================================================
 ! calculates the empirical melt rates of the iceberg as in 
 ! Martin: 'Parameterizing the fresh-water flux from land ice to ocean
 !          with interactive icebergs in a coupled climate model'(2010)
@@ -16,45 +16,39 @@
 !				use 3D information for T,S and velocities
 !				instead of SSTs; M_v depends on 'thermal driving')
 !==============================================================================
-subroutine iceberg_meltrates(   M_b, M_v, M_e, M_bv, &
+subroutine iceberg_meltrates(partit, M_b, M_v, M_e, M_bv, &
 				u_ib,v_ib, uo_ib,vo_ib, ua_ib,va_ib, &
 				sst_ib, length_ib, conci_ib, &
-				uo_keel_ib, vo_keel_ib, T_keel_ib, S_keel_ib, depth_ib, &
-				T_ave_ib, S_ave_ib, ib)
+				uo_keel_ib, vo_keel_ib, T_keel_ib, S_keel_ib, depth_ib, height_ib, &
+				T_ave_ib, S_ave_ib, ib, rho_icb)
   
-!  use o_mesh
   use o_param
-!  use i_therm_param
-!  use i_param
-!  use MOD_ICE
-!  use i_arrays
-!  use MOD_PARTIT
-
-! kh 18.03.21 not really used here
-! use o_arrays
-
+  use MOD_PARTIT
   use g_clock
   use g_forcing_arrays
   use g_rotate_grid
 
-  use iceberg_params, only: fwe_flux_ib, fwl_flux_ib, fwb_flux_ib, fwbv_flux_ib, heat_flux_ib
-  
+  use iceberg_params, only: fwe_flux_ib, fwl_flux_ib, fwb_flux_ib, fwbv_flux_ib, hfb_flux_ib, hfbv_flux_ib, hfe_flux_ib, hfl_flux_ib, scaling
   implicit none
   
+  ! LA: include latent heat 2023-04-04
+  real(kind=8),parameter ::  L                  = 334000.                   ! [J/Kg]
+  
   real, intent(IN)	:: u_ib,v_ib, uo_ib,vo_ib, ua_ib,va_ib	!iceberg velo, (int.) ocean & atm velo
   real, intent(IN)	:: uo_keel_ib, vo_keel_ib		!ocean velo at iceberg's draft
-  real, intent(IN)	:: sst_ib, length_ib, conci_ib 		!SST, length and sea ice conc.
-  real, intent(IN)	:: T_keel_ib, S_keel_ib, depth_ib	!T & S at depth 'depth_ib'
+  real, intent(IN)	:: sst_ib, length_ib, conci_ib, rho_icb 		!SST, length and sea ice conc.
+  real, intent(IN)	:: T_keel_ib, S_keel_ib, depth_ib, height_ib !T & S at depth 'depth_ib'
   real, intent(IN)	:: T_ave_ib, S_ave_ib			!T & S averaged, i.e. at 'depth_ib/2'
   integer, intent(IN)	:: ib					!iceberg ID
   real, intent(OUT)	:: M_b, M_v, M_e, M_bv			!melt rates [m (ice) per s]	
+  real 	            :: H_b, H_v, H_e, H_bv			!melt rates [m (ice) per s]	
   	
   
   real			:: absamino, damping, sea_state, v_ibmino
   real			:: tf, T_d 				!freezing temp. and 'thermal driving'
-!type(t_partit), intent(inout), target :: partit
-!#include "associate_part_def.h"
-!#include "associate_part_ass.h"
+type(t_partit), intent(inout), target :: partit
+#include "associate_part_def.h"
+#include "associate_part_ass.h"
   
   !bottom melt (basal turbulent melting rate)
   !M_b = 0.58 * sqrt( (u_ib - uo_ib)**2 + (v_ib - vo_ib)**2 )**0.8 &
@@ -63,17 +57,20 @@ subroutine iceberg_meltrates(   M_b, M_v, M_e, M_bv, &
 
   !3-eq. formulation for bottom melting [m/s]    
   v_ibmino  = sqrt( (u_ib - uo_keel_ib)**2 + (v_ib - vo_keel_ib)**2 )
-  call iceberg_heat_water_fluxes_3eq(ib, M_b, T_keel_ib,S_keel_ib,v_ibmino, depth_ib, tf)
+  call iceberg_heat_water_fluxes_3eq(partit, ib, M_b, H_b, T_keel_ib,S_keel_ib,v_ibmino, depth_ib, tf)
+  hfb_flux_ib(ib) = H_b * length_ib*length_ib*scaling(ib)
+!  write(*,*) "LA DEBUG: 1"
 
   !3-eq. formulation for lateral 'basal' melting [m/s]
   v_ibmino  = sqrt( (u_ib - uo_ib)**2 + (v_ib - vo_ib)**2 ) ! depth-average rel. velocity
-  call iceberg_heat_water_fluxes_3eq(ib, M_bv, T_ave_ib,S_ave_ib,v_ibmino, depth_ib/2.0, tf)
+  call iceberg_heat_water_fluxes_3eq(partit, ib, M_bv, H_bv, T_ave_ib,S_ave_ib,v_ibmino, depth_ib/2.0, tf)
+  hfbv_flux_ib(ib) = H_bv * (2*length_ib*abs(depth_ib)  + 2*length_ib*abs(depth_ib) ) * scaling(ib)
+!  write(*,*) "LA DEBUG: 2"
   
   !'thermal driving', defined as the elevation of ambient water 
   !temperature above freezing point' (Neshyba and Josberger, 1979).
   T_d = T_ave_ib - tf
   if(T_d < 0.) T_d = 0.
-  !write(*,*) 'thermal driving:',T_d,'; Tf:',tf,'T_ave:',T_ave_ib
 
   !lateral melt (buoyant convection)
   !M_v = 0.00762 * sst_ib + 0.00129 * sst_ib**2
@@ -81,6 +78,11 @@ subroutine iceberg_meltrates(   M_b, M_v, M_e, M_bv, &
   !M_v is a function of the 'thermal driving', NOT just sst! Cf. Neshyba and Josberger (1979)
   M_v = 0.00762 * T_d + 0.00129 * T_d**2
   M_v = M_v/86400.
+  H_v = M_v * rho_icb * L
+!  write(*,*) "!LA DEBUG: H_v=",H_v
+  hfl_flux_ib(ib) = H_v * (2*length_ib*abs(depth_ib)  + 2*length_ib*abs(depth_ib) ) * scaling(ib)
+!  write(*,*) "LA DEBUG: hfl_flux_ib=",hfl_flux_ib
+!  write(*,*) "LA DEBUG: 3"
   !fwl_flux_ib = M_v
 
   !wave erosion
@@ -89,6 +91,12 @@ subroutine iceberg_meltrates(   M_b, M_v, M_e, M_bv, &
   damping = 0.5 * (1.0 + cos(conci_ib**3 * Pi))
   M_e = 1./6. * sea_state * (sst_ib + 2.0) * damping
   M_e = M_e/86400.
+  H_e = M_e * rho_icb * L
+!  write(*,*) "LA DEBUG: H_e=",H_e
+!  write(*,*) "LA DEBUG: height=",height_ib
+  hfe_flux_ib(ib) = H_e * (length_ib*abs(height_ib)  + length_ib*abs(height_ib) ) * scaling(ib)
+!  write(*,*) "LA DEBUG: hfe_flux_ib=",hfe_flux_ib
+!  write(*,*) "LA DEBUG: 4"
   !fwe_flux_ib = M_e  
 end subroutine iceberg_meltrates
 
@@ -106,21 +114,12 @@ end subroutine iceberg_meltrates
 subroutine iceberg_newdimensions(partit, ib, depth_ib,height_ib,length_ib,width_ib,M_b,M_v,M_e,M_bv, &
 				 rho_h2o, rho_icb, file_meltrates)
   
-!  use o_mesh
   use o_param !for step_per_day
-!  use i_therm_param
-!  use i_param
-!  use MOD_ICE
-!  use i_arrays
   use MOD_PARTIT	!for mype
-
-! kh 18.03.21 not really used here
-! use o_arrays         
-
   use g_clock
   use g_forcing_arrays
   use g_rotate_grid
-  use iceberg_params, only: l_weeksmellor, ascii_out, icb_outfreq, vl_block, bvl_mean, lvlv_mean, lvle_mean, lvlb_mean, smallestvol_icb, fwb_flux_ib, fwe_flux_ib, fwbv_flux_ib, fwl_flux_ib, scaling, heat_flux_ib, lheat_flux_ib
+  use iceberg_params, only: l_weeksmellor, ascii_out, icb_outfreq, vl_block, bvl_mean, lvlv_mean, lvle_mean, lvlb_mean, smallestvol_icb, fwb_flux_ib, fwe_flux_ib, fwbv_flux_ib, fwl_flux_ib, scaling, hfb_flux_ib, hfbv_flux_ib, hfe_flux_ib, hfl_flux_ib, lhfb_flux_ib
   use g_config, only: steps_per_ib_step
 
   implicit none  
@@ -128,6 +127,7 @@ subroutine iceberg_newdimensions(partit, ib, depth_ib,height_ib,length_ib,width_
   integer, intent(IN)	:: ib
   real, intent(INOUT)	:: depth_ib, height_ib, length_ib, width_ib
   real, intent(IN)	:: M_b, M_v, M_e, M_bv, rho_h2o, rho_icb
+  real              :: hf_tot_tmp
   character, intent(IN)	:: file_meltrates*80
   
   real			:: dh_b, dh_v, dh_e, dh_bv, bvl, lvl_b, lvl_v, lvl_e, tvl, volume_before, volume_after
@@ -170,7 +170,7 @@ type(t_partit), intent(inout), target :: partit
 
     if((tvl .ge. volume_before) .OR. (volume_before .le. smallestvol_icb)) then
     	volume_after=0.0    	
-	depth_ib = 0.0
+	    depth_ib = 0.0
     	height_ib= 0.0
     	length_ib= 0.0
     	width_ib = 0.0
@@ -185,8 +185,6 @@ type(t_partit), intent(inout), target :: partit
     	volume_after=volume_before-tvl
     
     	!calculating the new iceberg dimensions
-    	!depth_ib = (abs(depth_ib)-dh_b)*(-1.)
-    	!height_ib= abs(depth_ib) * rho_h2o/rho_icb
 	height_ib=  height_ib - dh_b
 	depth_ib = -height_ib * rho_icb/rho_h2o
     
@@ -196,15 +194,13 @@ type(t_partit), intent(inout), target :: partit
     
     	!distribute dh_e equally between length and width
     	!as in code of michael schodlok, but not dh_v? 
-    	!length_ib= length_ib - dh_v -dh_e/2.
-    	!width_ib = width_ib  - dh_v -dh_e/2.
     
     	volume_after=height_ib*length_ib*width_ib
 
         !iceberg smaller than critical value after melting?
         if (volume_after .le. smallestvol_icb) then
             volume_after=0.0    	
-	    depth_ib = 0.0
+	        depth_ib = 0.0
     	    height_ib= 0.0
     	    length_ib= 0.0
     	    width_ib = 0.0
@@ -260,9 +256,18 @@ type(t_partit), intent(inout), target :: partit
     ! -----------------------
     ! LA: set iceberg heatflux at least to latent heat 2023-04-04
     ! Latent heat flux at base and sides also changes lines 475/476
-    lheat_flux_ib(ib) = rho_icb*L*tvl*scaling(ib)/dt/REAL(steps_per_ib_step)
-    if( (heat_flux_ib(ib).gt.0.0) .and. (heat_flux_ib(ib).lt.lheat_flux_ib(ib))) then
-        heat_flux_ib(ib)=lheat_flux_ib(ib)
+    ! Lateral heat flux set to latent heat and basal heat flux set to zero
+    if( lmin_latent_hf ) then
+        lhfb_flux_ib(ib) = rho_icb*L*tvl*scaling(ib)/dt/REAL(steps_per_ib_step)
+
+        hf_tot_tmp = hfb_flux_ib(ib)+hfbv_flux_ib(ib)+hfl_flux_ib(ib)+hfe_flux_ib(ib)
+
+        if( (hf_tot_tmp >= 0.0) .and. (abs(hf_tot_tmp) < abs(lhfb_flux_ib(ib)))) then
+            hfe_flux_ib(ib)=-lhfb_flux_ib(ib) * abs(hfe_flux_ib(ib)/hf_tot_tmp)
+            hfl_flux_ib(ib)=-lhfb_flux_ib(ib) * abs(hfl_flux_ib(ib)/hf_tot_tmp)
+            hfb_flux_ib(ib)=-lhfb_flux_ib(ib) * abs(hfb_flux_ib(ib)/hf_tot_tmp)
+            hfbv_flux_ib(ib)=-lhfb_flux_ib(ib) * abs(hfbv_flux_ib(ib)/hf_tot_tmp)
+        end if
     end if
     ! -----------------------
 end subroutine iceberg_newdimensions
@@ -297,25 +302,20 @@ end subroutine weeksmellor
  !***************************************************************************************************************************
  !***************************************************************************************************************************
 
-subroutine iceberg_heat_water_fluxes_3eq(ib, M_b, T_ib,S_ib,v_rel, depth_ib, t_freeze)
+subroutine iceberg_heat_water_fluxes_3eq(partit, ib, M_b, H_b, T_ib,S_ib,v_rel, depth_ib, t_freeze)
   ! The three-equation model of ice-shelf ocean interaction (Hellmer et al., 1997)
   ! Code derived from BRIOS subroutine iceshelf (which goes back to H.Hellmer's 2D ice shelf model code)
   ! adjusted for use in FESOM by Ralph Timmermann, 16.02.2011
   ! adopted and modified for iceberg basal melting by Thomas Rackow, 11.06.2014
   !----------------------------------------------------------------
 
-  !use o_mesh
-  !use o_param
-  !use o_arrays
-  !use i_arrays
-  !use MOD_PARTIT
   use iceberg_params
   use g_config
 
   implicit none
 
   integer, INTENT(IN)	  :: ib
-  real(kind=8),INTENT(OUT) :: M_b, t_freeze
+  real(kind=8),INTENT(OUT) :: M_b, H_b, t_freeze
   real(kind=8),INTENT(IN) :: T_ib, S_ib 	! ocean temperature & salinity (at depth 'depth_ib')
   real(kind=8),INTENT(IN) :: v_rel, depth_ib 	! relative velocity iceberg-ocean (at depth 'depth_ib')
 
@@ -351,22 +351,11 @@ subroutine iceberg_heat_water_fluxes_3eq(ib, M_b, T_ib,S_ib,v_rel, depth_ib, t_f
   real(kind=8),parameter ::  cpi =  152.5+7.122*(atk+tob)     !Paterson:"The Physics of Glaciers"
 
   real(kind=8),parameter ::  L    = 334000.                   ! [J/Kg]
+type(t_partit), intent(inout), target :: partit
+!==================== MODULES & DECLARATIONS ==========================!= 
+#include "associate_part_def.h"
+#include "associate_part_ass.h"
 
-  ! hemw = helium content of the glacial meltwater
-  ! oomw = isotopic fractionation due to melting
-  ! oofw = isotopic fractionation due to freezing
-  !      hemw=  4.02*14.
-  !      oomw= -30.
-  !      oofw= -2.5
-
-  !n3=myDim_nod3d+eDim_nod3d
-
-  !do n=1,myDim_nod2D+eDim_nod2D      
-     !if(cavity_flag_nod2d(n)==0) cycle   
-     !nk=nod3d_below_nod2d(1,n)
-     !temp = tracer(nk,1)	
-     !sal  = tracer(nk,2)
-     !zice = coord_nod3d(3,nk)  !(<0)
      temp = T_ib
      sal = S_ib
      zice = depth_ib !(<0)
@@ -378,15 +367,7 @@ subroutine iceberg_heat_water_fluxes_3eq(ib, M_b, T_ib,S_ib,v_rel, depth_ib, t_f
      ! Calculate or prescribe the turbulent heat and salt transfer coeff. GAT and GAS
      ! velocity-dependent approach of Jenkins (1991)
 
-     !rt      vt1  = 0.25*sqrt((u(i,j,N,lrhs)+u(i+1,j,N,lrhs))**2
-     !rt     &                +(v(i,j,N,lrhs)+v(i,j+1,N,lrhs))**2)
-     ! if(vt1.eq.0.) vt1=0.001
-     !rt      re   = Hz_r(i,j,N)*ds/un        !Reynolds number
-
-     !vt1  = sqrt(uf(nk)*uf(nk)+uf(nk+n3)*uf(nk+n3))   ! relative velocity ice-ocean
      vt1 = v_rel ! relative velocity iceberg-ocean (at depth 'depth_ib')
-
-!rt RG44030     vt1  = max(vt1,0.001)
      vt1  = max(vt1,0.005)       ! RG44030
 
      re   = 10./un                   !vt1*re (=velocity times length scale over kinematic viscosity) is the Reynolds number
@@ -466,17 +447,18 @@ subroutine iceberg_heat_water_fluxes_3eq(ib, M_b, T_ib,S_ib,v_rel, depth_ib, t_f
      endif
 
      t_freeze = tf ! output of freezing temperature
-
      ! Calculate the melting/freezing rate [m/s]
      ! seta = ep5*(1.0-sal/sf)     !rt thinks this is not needed; TR: Why different to M_b? LIQUID vs. ICE
 
      !rt  t_surf_flux(i,j)=gat*(tf-tin)
      !rt  s_surf_flux(i,j)=gas*(sf-(s(i,j,N,lrhs)+35.0))
 
-     !heat_flux_ib(ib)  = rhow*cpw*gat*(tin-tf)*scaling(ib)      ! [W/m2]  ! positive for upward
-     heat_flux_ib(ib)  = rhow*cpw*gat*(tin-tf)*length_ib(ib)*width_ib(ib)*scaling(ib)      ! [W]  ! positive for upward
+     !hfb_flux_ib(ib)  = rhow*cpw*gat*(tin-tf)*scaling(ib)      ! [W/m2]  ! positive for upward
+     !hfb_flux_ib(ib)  = rhow*cpw*gat*(tin-tf)*length_ib(ib)*width_ib(ib)*scaling(ib)      ! [W]  ! positive for upward
+     H_b  = rhow*cpw*gat*(tin-tf) !*length_ib(ib)*width_ib(ib)*scaling(ib)      ! [W]  ! positive for upward
+     
      !fw_flux_ib(ib) =          gas*(sf-sal)/sf   ! [m/s]   !
-      M_b 	    =          gas*(sf-sal)/sf   ! [m/s]   ! m freshwater per second
+     M_b 	    =          gas*(sf-sal)/sf   ! [m/s]   ! m freshwater per second
      !fw_flux_ib(ib) = M_b
      !fw = -M_b
      M_b = - (rhow / rhoi) * M_b 		 ! [m (ice) per second], positive for melting? NOW positive for melting
@@ -530,112 +512,6 @@ subroutine potit_ib(ib,salz,pt,pres,rfpres,tin)
   return
 end subroutine potit_ib
 
-! if the underlying FESOM is run without cavities, the following routines might be 
-! missing, so put them here:
-#ifndef use_cavity
-!
-!-------------------------------------------------------------------------------------
-!
-!subroutine potit(salz,pt,pres,rfpres,tin)
-!  ! Berechnet aus dem Salzgehalt[psu] (SALZ), der pot. Temperatur[oC]
-!  ! (PT) und dem Referenzdruck[dbar] (REFPRES) die in-situ Temperatur
-!  ! [oC] (TIN) bezogen auf den in-situ Druck[dbar] (PRES) mit Hilfe
-!  ! eines Iterationsverfahrens aus.
-!
-!  integer iter
-!  real salz,pt,pres,rfpres,tin
-!  real epsi,tpmd,pt1,ptd,pttmpr
-!
-!  data tpmd / 0.001 /
-!
-!  epsi = 0.
-!  do iter=1,100
-!     tin  = pt+epsi
-!     pt1  = pttmpr(salz,tin,pres,rfpres)
-!     ptd  = pt1-pt
-!     if(abs(ptd).lt.tpmd) return
-!     epsi = epsi-ptd
-!  enddo
-!  write(6,*) ' WARNING!'
-!  write(6,*) ' in-situ temperature calculation has not converged.'
-!  stop
-!  return
-!end subroutine potit
-!
-!-------------------------------------------------------------------------------------
-!
-!real function pttmpr(salz,temp,pres,rfpres)
-!  ! Berechnet aus dem Salzgehalt/psu (SALZ), der in-situ Temperatur/degC
-!  ! (TEMP) und dem in-situ Druck/dbar (PRES) die potentielle Temperatur/
-!  ! degC (PTTMPR) bezogen auf den Referenzdruck/dbar (RFPRES). Es wird
-!  ! ein Runge-Kutta Verfahren vierter Ordnung verwendet.
-!  ! Checkwert: PTTMPR = 36.89073 DegC
-!  !       fuer SALZ   =    40.0 psu
-!  !            TEMP   =    40.0 DegC
-!  !            PRES   = 10000.000 dbar
-!  !            RFPRES =     0.000 dbar
-!
-!  data ct2 ,ct3  /0.29289322 ,  1.707106781/
-!  data cq2a,cq2b /0.58578644 ,  0.121320344/
-!  data cq3a,cq3b /3.414213562, -4.121320344/
-!
-!  real salz,temp,pres,rfpres
-!  real p,t,dp,dt,q,ct2,ct3,cq2a,cq2b,cq3a,cq3b
-!  real adlprt
-!
-!  p  = pres
-!  t  = temp
-!  dp = rfpres-pres
-!  dt = dp*adlprt(salz,t,p)
-!  t  = t +0.5*dt
-!  q = dt
-!  p  = p +0.5*dp
-!  dt = dp*adlprt(salz,t,p)
-!  t  = t + ct2*(dt-q)
-!  q  = cq2a*dt + cq2b*q
-!  dt = dp*adlprt(salz,t,p)
-!  t  = t + ct3*(dt-q)
-!  q  = cq3a*dt + cq3b*q
-!  p  = rfpres
-!  dt = dp*adlprt(salz,t,p)
-!
-!  pttmpr = t + (dt-q-q)/6.0
-!
-!end function pttmpr
-!
-!-------------------------------------------------------------------------------------
-!
-!real function adlprt(salz,temp,pres)
-!  ! Berechnet aus dem Salzgehalt/psu (SALZ), der in-situ Temperatur/degC
-!  ! (TEMP) und dem in-situ Druck/dbar (PRES) den adiabatischen Temperatur-
-!  ! gradienten/(K Dbar^-1) ADLPRT.
-!  ! Checkwert: ADLPRT =     3.255976E-4 K dbar^-1
-!  !       fuer SALZ   =    40.0 psu
-!  !            TEMP   =    40.0 DegC
-!  !            PRES   = 10000.000 dbar
-!
-!  real salz,temp,pres
-!  real s0,a0,a1,a2,a3,b0,b1,c0,c1,c2,c3,d0,d1,e0,e1,e2,ds
-!
-!  data s0 /35.0/
-!  data a0,a1,a2,a3 /3.5803E-5, 8.5258E-6, -6.8360E-8, 6.6228E-10/
-!  data b0,b1       /1.8932E-6, -4.2393E-8/
-!  data c0,c1,c2,c3 /1.8741E-8, -6.7795E-10, 8.7330E-12, -5.4481E-14/
-!  data d0,d1       /-1.1351E-10, 2.7759E-12/
-!  data e0,e1,e2    /-4.6206E-13,  1.8676E-14, -2.1687E-16/
-!
-!  ds = salz-s0
-!  adlprt = ( ( (e2*temp + e1)*temp + e0 )*pres                     &
-!       + ( (d1*temp + d0)*ds                                  &
-!       + ( (c3*temp + c2)*temp + c1 )*temp + c0 ) )*pres   &
-!       + (b1*temp + b0)*ds +  ( (a3*temp + a2)*temp + a1 )*temp + a0
-!
-!END function adlprt
-!
-!----------------------------------------------------------------------------------------
-!
-#endif
-
 
 ! LA from oce_dens_press for iceberg coupling
 subroutine fcn_density(t,s,z,rho)
diff --git a/src/ice_oce_coupling.F90 b/src/ice_oce_coupling.F90
index 169e502e..2274f95f 100755
--- a/src/ice_oce_coupling.F90
+++ b/src/ice_oce_coupling.F90
@@ -259,6 +259,7 @@ subroutine oce_fluxes(ice, dynamics, tracers, partit, mesh)
     use icedrv_main,   only: icepack_to_fesom,    &
                             init_flux_atm_ocn
 #endif
+    use iceberg_params
     use cavity_interfaces
     !---fwf-code
     use g_clock
@@ -563,9 +564,21 @@ subroutine oce_fluxes(ice, dynamics, tracers, partit, mesh)
         end if 
     end if 
     
+    !___________________________________________________________________________
+    if (use_icebergs .and. lbalance_fw) then
+        call icb2fesom(mesh, partit, ice)
+        if (.not.turn_off_fw) then
+            flux = flux + (ibfwb + ibfwe + ibfwl + ibfwbv) !* steps_per_ib_step
+        end if
+        
+        call integrate_nod(ibfwb + ibfwe + ibfwl + ibfwbv, net, partit, mesh)
+        if (mype==0) write(*,*) " * total iceberg fw flux: ", net
+    end if
+
     !___________________________________________________________________________
     ! compute total global net freshwater flux into the ocean 
     call integrate_nod(flux, net, partit, mesh)
+
     
     !___________________________________________________________________________
     ! here the + sign must be used because we switched up the sign of the 
diff --git a/src/io_meandata.F90 b/src/io_meandata.F90
index 7ad34fe5..4b1aaec3 100644
--- a/src/io_meandata.F90
+++ b/src/io_meandata.F90
@@ -596,7 +596,8 @@ CASE ('icb       ')
     call def_stream(nod2D, myDim_nod2D, 'ibfwbv',  'basal iceberg melting',            'm/s',    ibfwbv(:),        1, 'm', i_real4, partit, mesh)
     call def_stream(nod2D, myDim_nod2D, 'ibfwl',   'lateral iceberg melting',          'm/s',    ibfwl(:),         1, 'm', i_real4, partit, mesh)
     call def_stream(nod2D, myDim_nod2D, 'ibfwe',   'iceberg erosion',                  'm/s',    ibfwe(:),         1, 'm', i_real4, partit, mesh)
-    call def_stream(nod2D, myDim_nod2D, 'ibhf',    'heat flux from iceberg melting',   'm/s',    ibhf(:),          1, 'm', i_real4, partit, mesh)
+    !call def_stream(nod2D, myDim_nod2D, 'ibhf',    'heat flux from iceberg melting',   'm/s',    ibhf(:),          1, 'm', i_real4, partit, mesh)
+    call def_stream((/nl,nod2D/), (/nl,myDim_nod2D/), 'ibhf',    'heat flux from iceberg melting',   'm/s',    ibhf_n(:,:),      1, 'm', i_real4, partit, mesh)
   end if
 !------------------------------------------
 
diff --git a/src/oce_ale_tracer.F90 b/src/oce_ale_tracer.F90
index b27f7541..c3d688f8 100644
--- a/src/oce_ale_tracer.F90
+++ b/src/oce_ale_tracer.F90
@@ -452,6 +452,7 @@ subroutine diff_ver_part_impl_ale(tr_num, dynamics, tracers, partit, mesh)
     use o_mixing_KPP_mod !for ghats _GO_   
     use g_cvmix_kpp, only: kpp_nonlcltranspT, kpp_nonlcltranspS, kpp_oblmixc
     use bc_surface_interface
+    use iceberg_params
     implicit none
     integer       , intent(in)   , target :: tr_num
     type(t_dyn)   , intent(inout), target :: dynamics
@@ -836,6 +837,17 @@ subroutine diff_ver_part_impl_ale(tr_num, dynamics, tracers, partit, mesh)
             end do
         end if
         
+        !_______________________________________________________________________
+        ! case of activated shortwave penetration into the ocean, ad 3d contribution
+        if (use_icebergs .and. (.not. turn_off_hf) .and. tracers%data(tr_num)%ID==1) then
+            do nz=nzmin, nzmax-1
+                zinv=1.0_WP*dt  !/(zbar(nz)-zbar(nz+1)) ale!
+                !!PS tr(nz)=tr(nz)+(sw_3d(nz, n)-sw_3d(nz+1, n) * ( area(nz+1,n)/areasvol(nz,n)) ) * zinv
+                !write(*,*) "LA DEBUG: n=",n,", nz=",nz,", ibhf_n(nz, n)=",ibhf_n(nz, n)
+                tr(nz)=tr(nz)+(ibhf_n(nz, n)-ibhf_n(nz+1, n) * area(nz+1,n)/areasvol(nz,n)) * zinv / vcpw
+            end do
+        end if
+        
         !_______________________________________________________________________
         !  The first row contains also the boundary condition from heatflux, 
         !  freshwaterflux and relaxation terms
